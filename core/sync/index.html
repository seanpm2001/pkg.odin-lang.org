<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>package sync - pkg.odin-lang.org</title>	<link rel="icon" href="/favicon.svg">
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/scss/custom.min.css">
	<link rel=stylesheet href="//odin-lang.org/lib/highlight/styles/github-dark.min.css">
	<script src="//odin-lang.org/lib/highlight/highlight.min.js"></script>

	<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
	<script>hljs.highlightAll()</script>
	<script>
		function toggleDarkMode() {
			if (document.body.classList.toggle("dark-mode")) {
				window.localStorage.setItem("theme", "dark");
			} else {
				window.localStorage.setItem("theme", "light");
			}
		}
	</script>
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/css/style.css">

	<link rel="stylesheet" type="text/css" href="/style.css">

	</style>
</head>
<body>
<script>
	if (window.localStorage.getItem("theme") === "dark")
		document.body.classList.add("dark-mode");
	else
		document.body.classList.remove("dark-mode");
</script>
<header class="sticky-top">
	<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
		<div class="container">
			<a class="navbar-brand" href="https://odin-lang.org/">
			<img src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#odin-navbar-content" aria-controls="odin-navbar-content" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
			<div class="collapse navbar-collapse" id="odin-navbar-content">
			<ul class="navbar-nav ms-md-auto">
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/">Home</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/docs">Docs</a></li>
				<li class="nav-item"><a class="nav-link active" href="/">Packages</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/news">News</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/showcase">Showcase</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/community">Community</a></li>
				<li class="nav-item"><a class="nav-link" href="https://github.com/odin-lang/Odin" target="_blank">GitHub</a></li>
				<li class="nav-item">
					<a
						class="nav-link btn-dark-mode"
						onclick="toggleDarkMode();"
						title="Toggle Light/Dark Mode"
					>
						<span class="dark-mode-appearance">Appearance:</span>
						<svg fill="white" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg>
						<svg fill="white" id="light-mode-icon" viewBox="0 0 16 16">
						  <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708"/>
						</svg>
					</button>
					</a>
				</li>
			</ul>
		</div>
		</div>
	</nav>
</header>
<main>
<div class="container full-width">
<div class="row odin-main my-4" id="pkg">
<nav id="pkg-sidebar" class="col-lg-2 odin-sidebar-border navbar-light sticky-top odin-below-navbar">
<div class="py-3">
<h4><a style="text-transform: capitalize; color: inherit;" href="/core">core Library</a></h4>
<ul>
<li class="nav-item"><a href="/core/bufio">bufio</a></li>
<li class="nav-item"><a href="/core/bytes">bytes</a></li>
<li class="nav-item"><a href="/core/c">c</a><ul>
<li><a href="/core/c/frontend/preprocessor">frontend/preprocessor</a></li>
<li><a href="/core/c/frontend/tokenizer">frontend/tokenizer</a></li>
<li><a href="/core/c/libc">libc</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/compress">compress</a><ul>
<li><a href="/core/compress/gzip">gzip</a></li>
<li><a href="/core/compress/shoco">shoco</a></li>
<li><a href="/core/compress/zlib">zlib</a></li>
</ul>

</li>
<li class="nav-item">container<ul>
<li><a href="/core/container/avl">avl</a></li>
<li><a href="/core/container/bit_array">bit_array</a></li>
<li><a href="/core/container/intrusive/list">intrusive/list</a></li>
<li><a href="/core/container/lru">lru</a></li>
<li><a href="/core/container/priority_queue">priority_queue</a></li>
<li><a href="/core/container/queue">queue</a></li>
<li><a href="/core/container/rbtree">rbtree</a></li>
<li><a href="/core/container/small_array">small_array</a></li>
<li><a href="/core/container/topological_sort">topological_sort</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/crypto">crypto</a><ul>
<li><a href="/core/crypto/aead">aead</a></li>
<li><a href="/core/crypto/aes">aes</a></li>
<li><a href="/core/crypto/blake2b">blake2b</a></li>
<li><a href="/core/crypto/blake2s">blake2s</a></li>
<li><a href="/core/crypto/chacha20">chacha20</a></li>
<li><a href="/core/crypto/chacha20poly1305">chacha20poly1305</a></li>
<li><a href="/core/crypto/ed25519">ed25519</a></li>
<li><a href="/core/crypto/hash">hash</a></li>
<li><a href="/core/crypto/hkdf">hkdf</a></li>
<li><a href="/core/crypto/hmac">hmac</a></li>
<li><a href="/core/crypto/kmac">kmac</a></li>
<li><a href="/core/crypto/legacy/keccak">legacy/keccak</a></li>
<li><a href="/core/crypto/legacy/md5">legacy/md5</a></li>
<li><a href="/core/crypto/legacy/sha1">legacy/sha1</a></li>
<li><a href="/core/crypto/pbkdf2">pbkdf2</a></li>
<li><a href="/core/crypto/poly1305">poly1305</a></li>
<li><a href="/core/crypto/ristretto255">ristretto255</a></li>
<li><a href="/core/crypto/sha2">sha2</a></li>
<li><a href="/core/crypto/sha3">sha3</a></li>
<li><a href="/core/crypto/shake">shake</a></li>
<li><a href="/core/crypto/sm3">sm3</a></li>
<li><a href="/core/crypto/tuplehash">tuplehash</a></li>
<li><a href="/core/crypto/x25519">x25519</a></li>
</ul>

</li>
<li class="nav-item">debug<ul>
<li><a href="/core/debug/pe">pe</a></li>
<li><a href="/core/debug/trace">trace</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/dynlib">dynlib</a></li>
<li class="nav-item">encoding<ul>
<li><a href="/core/encoding/ansi">ansi</a></li>
<li><a href="/core/encoding/base32">base32</a></li>
<li><a href="/core/encoding/base64">base64</a></li>
<li><a href="/core/encoding/cbor">cbor</a></li>
<li><a href="/core/encoding/csv">csv</a></li>
<li><a href="/core/encoding/endian">endian</a></li>
<li><a href="/core/encoding/entity">entity</a></li>
<li><a href="/core/encoding/hex">hex</a></li>
<li><a href="/core/encoding/hxa">hxa</a></li>
<li><a href="/core/encoding/ini">ini</a></li>
<li><a href="/core/encoding/json">json</a></li>
<li><a href="/core/encoding/uuid">uuid</a></li>
<li><a href="/core/encoding/uuid/legacy">uuid/legacy</a></li>
<li><a href="/core/encoding/varint">varint</a></li>
<li><a href="/core/encoding/xml">xml</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/flags">flags</a></li>
<li class="nav-item"><a href="/core/fmt">fmt</a></li>
<li class="nav-item"><a href="/core/hash">hash</a><ul>
<li><a href="/core/hash/xxhash">xxhash</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/image">image</a><ul>
<li><a href="/core/image/bmp">bmp</a></li>
<li><a href="/core/image/netpbm">netpbm</a></li>
<li><a href="/core/image/png">png</a></li>
<li><a href="/core/image/qoi">qoi</a></li>
<li><a href="/core/image/tga">tga</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/io">io</a></li>
<li class="nav-item"><a href="/core/log">log</a></li>
<li class="nav-item"><a href="/core/math">math</a><ul>
<li><a href="/core/math/big">big</a></li>
<li><a href="/core/math/bits">bits</a></li>
<li><a href="/core/math/cmplx">cmplx</a></li>
<li><a href="/core/math/ease">ease</a></li>
<li><a href="/core/math/fixed">fixed</a></li>
<li><a href="/core/math/linalg">linalg</a></li>
<li><a href="/core/math/linalg/glsl">linalg/glsl</a></li>
<li><a href="/core/math/linalg/hlsl">linalg/hlsl</a></li>
<li><a href="/core/math/noise">noise</a></li>
<li><a href="/core/math/rand">rand</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/mem">mem</a><ul>
<li><a href="/core/mem/tlsf">tlsf</a></li>
<li><a href="/core/mem/virtual">virtual</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/net">net</a></li>
<li class="nav-item">odin<ul>
<li><a href="/core/odin/ast">ast</a></li>
<li><a href="/core/odin/doc-format">doc-format</a></li>
<li><a href="/core/odin/parser">parser</a></li>
<li><a href="/core/odin/tokenizer">tokenizer</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/os">os</a></li>
<li class="nav-item">path<ul>
<li><a href="/core/path/filepath">filepath</a></li>
<li><a href="/core/path/slashpath">slashpath</a></li>
</ul>

</li>
<li class="nav-item">prof<ul>
<li><a href="/core/prof/spall">spall</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/reflect">reflect</a></li>
<li class="nav-item"><a href="/core/relative">relative</a></li>
<li class="nav-item"><a href="/core/simd">simd</a><ul>
<li><a href="/core/simd/x86">x86</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/slice">slice</a><ul>
<li><a href="/core/slice/heap">heap</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/sort">sort</a></li>
<li class="nav-item"><a href="/core/strconv">strconv</a><ul>
<li><a href="/core/strconv/decimal">decimal</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/strings">strings</a></li>
<li class="nav-item"><a class="active" href="/core/sync">sync</a><ul>
<li><a href="/core/sync/chan">chan</a></li>
</ul>

</li>
<li class="nav-item">sys<ul>
<li><a href="/core/sys/darwin">darwin</a></li>
<li><a href="/core/sys/darwin/Foundation">darwin/Foundation</a></li>
<li><a href="/core/sys/haiku">haiku</a></li>
<li><a href="/core/sys/info">info</a></li>
<li><a href="/core/sys/linux">linux</a></li>
<li><a href="/core/sys/orca">orca</a></li>
<li><a href="/core/sys/posix">posix</a></li>
<li><a href="/core/sys/valgrind">valgrind</a></li>
<li><a href="/core/sys/windows">windows</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/testing">testing</a></li>
<li class="nav-item">text<ul>
<li><a href="/core/text/edit">edit</a></li>
<li><a href="/core/text/i18n">i18n</a></li>
<li><a href="/core/text/match">match</a></li>
<li><a href="/core/text/regex">regex</a></li>
<li><a href="/core/text/regex/common">regex/common</a></li>
<li><a href="/core/text/regex/compiler">regex/compiler</a></li>
<li><a href="/core/text/regex/optimizer">regex/optimizer</a></li>
<li><a href="/core/text/regex/parser">regex/parser</a></li>
<li><a href="/core/text/regex/tokenizer">regex/tokenizer</a></li>
<li><a href="/core/text/regex/virtual_machine">regex/virtual_machine</a></li>
<li><a href="/core/text/scanner">scanner</a></li>
<li><a href="/core/text/table">table</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/thread">thread</a></li>
<li class="nav-item"><a href="/core/time">time</a><ul>
<li><a href="/core/time/datetime">datetime</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/unicode">unicode</a><ul>
<li><a href="/core/unicode/utf16">utf16</a></li>
<li><a href="/core/unicode/utf8">utf8</a></li>
<li><a href="/core/unicode/utf8/utf8string">utf8/utf8string</a></li>
</ul>

</li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4 documentation odin-article">
<nav class="pkg-breadcrumb" aria-label="breadcrumb">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a href="/core">core</a></li>
<li class="breadcrumb-item active" aria-current="page"><a href="/core/sync">sync</a></li>
</ol>
</nav>
<h1>package core:sync<div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync"><em>Source</em></a></div></h1>

		<div class="odin-search-wrapper">
			<input type="search" id="odin-search" class="odin-search-package" autocomplete="off" spellcheck="false" placeholder="Fuzzy Search...">
			<div class="odin-search-shortcut">
				<div class="odin-search-key key-macos">⌘K</div>
				<div class="odin-search-key key-windows">Ctrl+K</div>
				<span class="odin-search-or">or</span>
				<div class="odin-search-key">/</div>
			</div>
		</div>
	
<div id="odin-search-info">
<div id="odin-search-time"></div>

		<div id="odin-search-options">
			<input type="checkbox" id="odin-search-filter" name="odin-search-filter">
			<label for="odin-search-filter">Filter Results</label>
		</div>
</div>
<ul id="odin-search-results"></ul>
<div id="pkg-top">
<h2>Overview</h2>
<div id="pkg-overview">
<p>Synchronization primitives</p>
<p>This package implements various synchronization primitives that can be used to
synchronize threads' access to shared memory.</p>
<p>To limit or control the threads' access to shared memory typically the
following approaches are used:</p>
<p><span class="doc-list">Locks</span>
<span class="doc-list">Lock-free</span></p>
<p>When using locks, sections of the code that access shared memory (also known as
<b>critical sections</b>) are guarded by locks, allowing limited access to threads
and blocking the execution of any other threads.</p>
<p>In lock-free programming the data itself is organized in such a way that threads
don't intervene much. It can be done via segmenting the data between threads,
and/or by using atomic operations.</p>
</div>
<div id="pkg-index">
<h2>Index</h2>
<div>
<details class="doc-index" id="doc-index-Types" aria-labelledby="#doc-index-Types-header">
<summary id="#doc-index-Types-header">
Types (23)</summary>
<ul>
<li><a href="#Atomic_Cond">Atomic_Cond</a></li>
<li><a href="#Atomic_Memory_Order">Atomic_Memory_Order</a></li>
<li><a href="#Atomic_Mutex">Atomic_Mutex</a></li>
<li><a href="#Atomic_Mutex_State">Atomic_Mutex_State</a></li>
<li><a href="#Atomic_RW_Mutex">Atomic_RW_Mutex</a></li>
<li><a href="#Atomic_RW_Mutex_State">Atomic_RW_Mutex_State</a></li>
<li><a href="#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex</a></li>
<li><a href="#Atomic_Sema">Atomic_Sema</a></li>
<li><a href="#Auto_Reset_Event">Auto_Reset_Event</a></li>
<li><a href="#Barrier">Barrier</a></li>
<li><a href="#Benaphore">Benaphore</a></li>
<li><a href="#Cond">Cond</a></li>
<li><a href="#Futex">Futex</a></li>
<li><a href="#Mutex">Mutex</a></li>
<li><a href="#Once">Once</a></li>
<li><a href="#One_Shot_Event">One_Shot_Event</a></li>
<li><a href="#Parker">Parker</a></li>
<li><a href="#RW_Mutex">RW_Mutex</a></li>
<li><a href="#Recursive_Benaphore">Recursive_Benaphore</a></li>
<li><a href="#Recursive_Mutex">Recursive_Mutex</a></li>
<li><a href="#Sema">Sema</a></li>
<li><a href="#Ticket_Mutex">Ticket_Mutex</a></li>
<li><a href="#Wait_Group">Wait_Group</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Constants" aria-labelledby="#doc-index-Constants-header">
<summary id="#doc-index-Constants-header">
Constants (6)</summary>
<ul>
<li><a href="#Atomic_RW_Mutex_State_Half_Width">Atomic_RW_Mutex_State_Half_Width</a></li>
<li><a href="#Atomic_RW_Mutex_State_Is_Writing">Atomic_RW_Mutex_State_Is_Writing</a></li>
<li><a href="#Atomic_RW_Mutex_State_Reader">Atomic_RW_Mutex_State_Reader</a></li>
<li><a href="#Atomic_RW_Mutex_State_Reader_Mask">Atomic_RW_Mutex_State_Reader_Mask</a></li>
<li><a href="#Atomic_RW_Mutex_State_Writer">Atomic_RW_Mutex_State_Writer</a></li>
<li><a href="#Atomic_RW_Mutex_State_Writer_Mask">Atomic_RW_Mutex_State_Writer_Mask</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Variables" aria-labelledby="#doc-index-Variables-header">
<summary id="#doc-index-Variables-header">
Variables (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedures" aria-labelledby="#doc-index-Procedures-header">
<summary id="#doc-index-Procedures-header">
Procedures (104)</summary>
<ul>
<li><a href="#atomic_add">atomic_add</a></li>
<li><a href="#atomic_add_explicit">atomic_add_explicit</a></li>
<li><a href="#atomic_and">atomic_and</a></li>
<li><a href="#atomic_and_explicit">atomic_and_explicit</a></li>
<li><a href="#atomic_compare_exchange_strong">atomic_compare_exchange_strong</a></li>
<li><a href="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</a></li>
<li><a href="#atomic_compare_exchange_weak">atomic_compare_exchange_weak</a></li>
<li><a href="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</a></li>
<li><a href="#atomic_cond_broadcast">atomic_cond_broadcast</a></li>
<li><a href="#atomic_cond_signal">atomic_cond_signal</a></li>
<li><a href="#atomic_cond_wait">atomic_cond_wait</a></li>
<li><a href="#atomic_cond_wait_with_timeout">atomic_cond_wait_with_timeout</a></li>
<li><a href="#atomic_exchange">atomic_exchange</a></li>
<li><a href="#atomic_exchange_explicit">atomic_exchange_explicit</a></li>
<li><a href="#atomic_load">atomic_load</a></li>
<li><a href="#atomic_load_explicit">atomic_load_explicit</a></li>
<li><a href="#atomic_mutex_guard">atomic_mutex_guard</a></li>
<li><a href="#atomic_mutex_lock">atomic_mutex_lock</a></li>
<li><a href="#atomic_mutex_try_lock">atomic_mutex_try_lock</a></li>
<li><a href="#atomic_mutex_unlock">atomic_mutex_unlock</a></li>
<li><a href="#atomic_nand">atomic_nand</a></li>
<li><a href="#atomic_nand_explicit">atomic_nand_explicit</a></li>
<li><a href="#atomic_or">atomic_or</a></li>
<li><a href="#atomic_or_explicit">atomic_or_explicit</a></li>
<li><a href="#atomic_recursive_mutex_guard">atomic_recursive_mutex_guard</a></li>
<li><a href="#atomic_recursive_mutex_lock">atomic_recursive_mutex_lock</a></li>
<li><a href="#atomic_recursive_mutex_try_lock">atomic_recursive_mutex_try_lock</a></li>
<li><a href="#atomic_recursive_mutex_unlock">atomic_recursive_mutex_unlock</a></li>
<li><a href="#atomic_rw_mutex_guard">atomic_rw_mutex_guard</a></li>
<li><a href="#atomic_rw_mutex_lock">atomic_rw_mutex_lock</a></li>
<li><a href="#atomic_rw_mutex_shared_guard">atomic_rw_mutex_shared_guard</a></li>
<li><a href="#atomic_rw_mutex_shared_lock">atomic_rw_mutex_shared_lock</a></li>
<li><a href="#atomic_rw_mutex_shared_unlock">atomic_rw_mutex_shared_unlock</a></li>
<li><a href="#atomic_rw_mutex_try_lock">atomic_rw_mutex_try_lock</a></li>
<li><a href="#atomic_rw_mutex_try_shared_lock">atomic_rw_mutex_try_shared_lock</a></li>
<li><a href="#atomic_rw_mutex_unlock">atomic_rw_mutex_unlock</a></li>
<li><a href="#atomic_sema_post">atomic_sema_post</a></li>
<li><a href="#atomic_sema_wait">atomic_sema_wait</a></li>
<li><a href="#atomic_sema_wait_with_timeout">atomic_sema_wait_with_timeout</a></li>
<li><a href="#atomic_signal_fence">atomic_signal_fence</a></li>
<li><a href="#atomic_store">atomic_store</a></li>
<li><a href="#atomic_store_explicit">atomic_store_explicit</a></li>
<li><a href="#atomic_sub">atomic_sub</a></li>
<li><a href="#atomic_sub_explicit">atomic_sub_explicit</a></li>
<li><a href="#atomic_thread_fence">atomic_thread_fence</a></li>
<li><a href="#atomic_xor">atomic_xor</a></li>
<li><a href="#atomic_xor_explicit">atomic_xor_explicit</a></li>
<li><a href="#auto_reset_event_signal">auto_reset_event_signal</a></li>
<li><a href="#auto_reset_event_wait">auto_reset_event_wait</a></li>
<li><a href="#barrier_init">barrier_init</a></li>
<li><a href="#barrier_wait">barrier_wait</a></li>
<li><a href="#benaphore_guard">benaphore_guard</a></li>
<li><a href="#benaphore_lock">benaphore_lock</a></li>
<li><a href="#benaphore_try_lock">benaphore_try_lock</a></li>
<li><a href="#benaphore_unlock">benaphore_unlock</a></li>
<li><a href="#cond_broadcast">cond_broadcast</a></li>
<li><a href="#cond_signal">cond_signal</a></li>
<li><a href="#cond_wait">cond_wait</a></li>
<li><a href="#cond_wait_with_timeout">cond_wait_with_timeout</a></li>
<li><a href="#cpu_relax">cpu_relax</a></li>
<li><a href="#current_thread_id">current_thread_id</a></li>
<li><a href="#futex_broadcast">futex_broadcast</a></li>
<li><a href="#futex_signal">futex_signal</a></li>
<li><a href="#futex_wait">futex_wait</a></li>
<li><a href="#futex_wait_with_timeout">futex_wait_with_timeout</a></li>
<li><a href="#mutex_guard">mutex_guard</a></li>
<li><a href="#mutex_lock">mutex_lock</a></li>
<li><a href="#mutex_try_lock">mutex_try_lock</a></li>
<li><a href="#mutex_unlock">mutex_unlock</a></li>
<li><a href="#once_do_with_data">once_do_with_data</a></li>
<li><a href="#once_do_with_data_contextless">once_do_with_data_contextless</a></li>
<li><a href="#once_do_without_data">once_do_without_data</a></li>
<li><a href="#once_do_without_data_contextless">once_do_without_data_contextless</a></li>
<li><a href="#one_shot_event_signal">one_shot_event_signal</a></li>
<li><a href="#one_shot_event_wait">one_shot_event_wait</a></li>
<li><a href="#park">park</a></li>
<li><a href="#park_with_timeout">park_with_timeout</a></li>
<li><a href="#recursive_benaphore_guard">recursive_benaphore_guard</a></li>
<li><a href="#recursive_benaphore_lock">recursive_benaphore_lock</a></li>
<li><a href="#recursive_benaphore_try_lock">recursive_benaphore_try_lock</a></li>
<li><a href="#recursive_benaphore_unlock">recursive_benaphore_unlock</a></li>
<li><a href="#recursive_mutex_guard">recursive_mutex_guard</a></li>
<li><a href="#recursive_mutex_lock">recursive_mutex_lock</a></li>
<li><a href="#recursive_mutex_try_lock">recursive_mutex_try_lock</a></li>
<li><a href="#recursive_mutex_unlock">recursive_mutex_unlock</a></li>
<li><a href="#rw_mutex_guard">rw_mutex_guard</a></li>
<li><a href="#rw_mutex_lock">rw_mutex_lock</a></li>
<li><a href="#rw_mutex_shared_guard">rw_mutex_shared_guard</a></li>
<li><a href="#rw_mutex_shared_lock">rw_mutex_shared_lock</a></li>
<li><a href="#rw_mutex_shared_unlock">rw_mutex_shared_unlock</a></li>
<li><a href="#rw_mutex_try_lock">rw_mutex_try_lock</a></li>
<li><a href="#rw_mutex_try_shared_lock">rw_mutex_try_shared_lock</a></li>
<li><a href="#rw_mutex_unlock">rw_mutex_unlock</a></li>
<li><a href="#sema_post">sema_post</a></li>
<li><a href="#sema_wait">sema_wait</a></li>
<li><a href="#sema_wait_with_timeout">sema_wait_with_timeout</a></li>
<li><a href="#ticket_mutex_guard">ticket_mutex_guard</a></li>
<li><a href="#ticket_mutex_lock">ticket_mutex_lock</a></li>
<li><a href="#ticket_mutex_unlock">ticket_mutex_unlock</a></li>
<li><a href="#unpark">unpark</a></li>
<li><a href="#wait_group_add">wait_group_add</a></li>
<li><a href="#wait_group_done">wait_group_done</a></li>
<li><a href="#wait_group_wait">wait_group_wait</a></li>
<li><a href="#wait_group_wait_with_timeout">wait_group_wait_with_timeout</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedure Groups" aria-labelledby="#doc-index-Procedure Groups-header">
<summary id="#doc-index-Procedure Groups-header">
Procedure Groups (14)</summary>
<ul>
<li><a href="#broadcast">broadcast</a></li>
<li><a href="#guard">guard</a></li>
<li><a href="#lock">lock</a></li>
<li><a href="#once_do">once_do</a></li>
<li><a href="#post">post</a></li>
<li><a href="#shared_guard">shared_guard</a></li>
<li><a href="#shared_lock">shared_lock</a></li>
<li><a href="#shared_unlock">shared_unlock</a></li>
<li><a href="#signal">signal</a></li>
<li><a href="#try_lock">try_lock</a></li>
<li><a href="#try_shared_lock">try_shared_lock</a></li>
<li><a href="#unlock">unlock</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#wait_with_timeout">wait_with_timeout</a></li>
</ul>
</details>
</div>
</div>
</div>
<section class="documentation">
<h2 id="pkg-Types" class="pkg-header">Types</h2>
<div class="pkg-entity">
<h3 id="Atomic_Cond"><span><a class="doc-id-link" href="#Atomic_Cond">Atomic_Cond<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L288"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_Cond :: <span class="keyword-type">struct</span> {
	state: <a class="code-typename" href="/core/sync/#Futex">Futex</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomic_Cond implements a condition variable, a rendezvous point for threads
waiting for signalling the occurence of an event</p>
<p>An Atomic_Cond must not be copied after first use</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#atomic_cond_broadcast">atomic_cond_broadcast</a></li>
<li><a href="/core/sync/#atomic_cond_signal">atomic_cond_signal</a></li>
<li><a href="/core/sync/#atomic_cond_wait">atomic_cond_wait</a></li>
<li><a href="/core/sync/#atomic_cond_wait_with_timeout">atomic_cond_wait_with_timeout</a></li>
<li><a href="/core/sync/#broadcast">broadcast</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#signal">signal</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Atomic_Memory_Order"><span><a class="doc-id-link" href="#Atomic_Memory_Order">Atomic_Memory_Order<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/atomic.odin#L73"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_Memory_Order :: .<a class="code-typename" href="//#Atomic_Memory_Order">Atomic_Memory_Order</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Describes memory ordering for an atomic operation.</p>
<p>Modern CPU's contain multiple cores and caches specific to those cores. When a
core performs a write to memory, the value is written to cache first. The issue
is that a core doesn't typically see what's inside the caches of other cores.
In order to make operations consistent CPU's implement mechanisms that
synchronize memory operations across cores by asking other cores or by
pushing data about writes to other cores.</p>
<p>Due to how these algorithms are implemented, the stores and loads performed by
one core may seem to happen in a different order to another core. It also may
happen that a core reorders stores and loads (independent of how compiler put
them into the machine code). This can cause issues when trying to synchronize
multiple memory locations between two cores. Which is why CPU's allow for
stronger memory ordering guarantees if certain instructions or instruction
variants are used.</p>
<p>In Odin there are 5 different memory ordering guaranties that can be provided
to an atomic operation:</p>
<p><span class="doc-list"><code>Relaxed</code>: The memory access (load or store) is unordered with respect to</span>
  other memory accesses. This can be used to implement an atomic counter.
  Multiple threads access a single variable, but it doesn't matter when
  exactly it gets incremented, because it will become eventually consistent.
<span class="doc-list"><code>Consume</code>: No loads or stores dependent on a memory location can be</span>
  reordered before a load with consume memory order. If other threads released
  the same memory, it becomes visible.
<span class="doc-list"><code>Acquire</code>: No loads or stores on a memory location can be reordered before a</span>
  load of that memory location with acquire memory ordering. If other threads
  release the same memory, it becomes visible.
<span class="doc-list"><code>Release</code>: No loads or stores on a memory location can be reordered after a</span>
  store of that memory location with release memory ordering. All threads that
  acquire the same memory location will see all writes done by the current
  thread.
<span class="doc-list"><code>Acq_Rel</code>: Acquire-release memory ordering: combines acquire and release</span>
  memory orderings in the same operation.
<span class="doc-list"><code>Seq_Cst</code>: Sequential consistency. The strongest memory ordering. A load will</span>
  always be an acquire operation, a store will always be a release operation,
  and in addition to that all threads observe the same order of writes.</p>
<p>Non-explicit atomics will always be sequentially consistent.</p>
<pre>Atomic_Memory_Order :: enum {
	Relaxed = 0, // Unordered
	Consume = 1, // Monotonic
	Acquire = 2,
	Release = 3,
	Acq_Rel = 4,
	Seq_Cst = 5,
}

</pre>
<p><b>Note(i386, x64)</b>: x86 has a very strong memory model by default. It
guarantees that all writes are ordered, stores and loads aren't reordered. In
a sense, all operations are at least acquire and release operations. If <code>lock</code>
prefix is used, all operations are sequentially consistent. If you use explicit
atomics, make sure you have the correct atomic memory order, because bugs likely
will not show up in x86, but may show up on e.g. arm. More on x86 memory
ordering can be found
<a href="https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf">here</a></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Atomic_Mutex"><span><a class="doc-id-link" href="#Atomic_Mutex">Atomic_Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L16"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_Mutex :: <span class="keyword-type">struct</span> {
	state: <a class="code-typename" href="/core/sync/#Atomic_Mutex_State">Atomic_Mutex_State</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>An Atomic_Mutex is a mutual exclusion lock
The zero value for a Atomic_Mutex is an unlocked mutex</p>
<p>An Atomic_Mutex must not be copied after first use</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#atomic_cond_wait">atomic_cond_wait</a></li>
<li><a href="/core/sync/#atomic_cond_wait_with_timeout">atomic_cond_wait_with_timeout</a></li>
<li><a href="/core/sync/#atomic_mutex_guard">atomic_mutex_guard</a></li>
<li><a href="/core/sync/#atomic_mutex_lock">atomic_mutex_lock</a></li>
<li><a href="/core/sync/#atomic_mutex_try_lock">atomic_mutex_try_lock</a></li>
<li><a href="/core/sync/#atomic_mutex_unlock">atomic_mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Atomic_Mutex_State"><span><a class="doc-id-link" href="#Atomic_Mutex_State">Atomic_Mutex_State<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L5"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_Mutex_State :: <span class="keyword-type">enum</span> <a class="code-typename" href="/core/sync/#Futex">Futex</a> {
	Unlocked = 0, 
	Locked   = 1, 
	Waiting  = 2, 
}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex"><span><a class="doc-id-link" href="#Atomic_RW_Mutex">Atomic_RW_Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L112"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex :: <span class="keyword-type">struct</span> {
	state: <a class="code-typename" href="/core/sync/#Atomic_RW_Mutex_State">Atomic_RW_Mutex_State</a>,
	mutex: <a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>,
	sema:  <a class="code-typename" href="/core/sync/#Atomic_Sema">Atomic_Sema</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>An Atomic_RW_Mutex is a reader/writer mutual exclusion lock
The lock can be held by any arbitrary number of readers or a single writer
The zero value for an Atomic_RW_Mutex is an unlocked mutex</p>
<p>An Atomic_RW_Mutex must not be copied after first use</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#atomic_rw_mutex_guard">atomic_rw_mutex_guard</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_lock">atomic_rw_mutex_lock</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_shared_guard">atomic_rw_mutex_shared_guard</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_shared_lock">atomic_rw_mutex_shared_lock</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_shared_unlock">atomic_rw_mutex_shared_unlock</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_try_lock">atomic_rw_mutex_try_lock</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_try_shared_lock">atomic_rw_mutex_try_shared_lock</a></li>
<li><a href="/core/sync/#atomic_rw_mutex_unlock">atomic_rw_mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#shared_guard">shared_guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#shared_lock">shared_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#shared_unlock">shared_unlock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_shared_lock">try_shared_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State">Atomic_RW_Mutex_State<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L97"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State :: <span class="keyword-type">distinct</span> <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a></pre>
</div>
<h5>Related Constants</h5>
<ul>
<li><a href="/core/sync/#Atomic_RW_Mutex_State_Is_Writing">Atomic_RW_Mutex_State_Is_Writing</a></li>
<li><a href="/core/sync/#Atomic_RW_Mutex_State_Reader">Atomic_RW_Mutex_State_Reader</a></li>
<li><a href="/core/sync/#Atomic_RW_Mutex_State_Reader_Mask">Atomic_RW_Mutex_State_Reader_Mask</a></li>
<li><a href="/core/sync/#Atomic_RW_Mutex_State_Writer">Atomic_RW_Mutex_State_Writer</a></li>
<li><a href="/core/sync/#Atomic_RW_Mutex_State_Writer_Mask">Atomic_RW_Mutex_State_Writer_Mask</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Atomic_Recursive_Mutex"><span><a class="doc-id-link" href="#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L225"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_Recursive_Mutex :: <span class="keyword-type">struct</span> {
	owner:     <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	recursion: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	mutex:     <a class="code-typename" href="/core/sync/#Mutex">Mutex</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>An Atomic_Recursive_Mutex is a recursive mutual exclusion lock
The zero value for a Recursive_Mutex is an unlocked mutex</p>
<p>An Atomic_Recursive_Mutex must not be copied after first use</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#atomic_recursive_mutex_guard">atomic_recursive_mutex_guard</a></li>
<li><a href="/core/sync/#atomic_recursive_mutex_lock">atomic_recursive_mutex_lock</a></li>
<li><a href="/core/sync/#atomic_recursive_mutex_try_lock">atomic_recursive_mutex_try_lock</a></li>
<li><a href="/core/sync/#atomic_recursive_mutex_unlock">atomic_recursive_mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Atomic_Sema"><span><a class="doc-id-link" href="#Atomic_Sema">Atomic_Sema<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L323"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_Sema :: <span class="keyword-type">struct</span> {
	count: <a class="code-typename" href="/core/sync/#Futex">Futex</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>When waited upon, blocks until the internal count is greater than zero, then subtracts one.
Posting to the semaphore increases the count by one, or the provided amount.</p>
<p>An Atomic_Sema must not be copied after first use</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#atomic_sema_post">atomic_sema_post</a></li>
<li><a href="/core/sync/#atomic_sema_wait">atomic_sema_wait</a></li>
<li><a href="/core/sync/#atomic_sema_wait_with_timeout">atomic_sema_wait_with_timeout</a></li>
<li><a href="/core/sync/#post">post</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Auto_Reset_Event"><span><a class="doc-id-link" href="#Auto_Reset_Event">Auto_Reset_Event<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L215"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Auto_Reset_Event :: <span class="keyword-type">struct</span> {
	<span class="comment">// status ==  0: Event is reset and no threads are waiting</span>
	<span class="comment">// status ==  1: Event is signalled</span>
	<span class="comment">// status == -N: Event is reset and N threads are waiting</span>
	status: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a>,
	sema:   <a class="code-typename" href="/core/sync/#Sema">Sema</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Auto-reset event.</p>
<p>Represents a thread synchronization primitive that, when signalled, releases one
single waiting thread and then resets automatically to a state where it can be
signalled again.</p>
<p>When a thread calls <code>auto_reset_event_wait</code>, its execution will be blocked,
until the event is signalled by another thread. The call to
<code>auto_reset_event_signal</code> wakes up exactly one thread waiting for the event.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#auto_reset_event_signal">auto_reset_event_signal</a></li>
<li><a href="/core/sync/#auto_reset_event_wait">auto_reset_event_wait</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Barrier"><span><a class="doc-id-link" href="#Barrier">Barrier<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L153"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Barrier :: <span class="keyword-type">struct</span> {
	mutex:         <a class="code-typename" href="/core/sync/#Mutex">Mutex</a>,
	cond:          <a class="code-typename" href="/core/sync/#Cond">Cond</a>,
	index:         <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	generation_id: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	thread_count:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Barrier.</p>
<p>A barrier is a synchronization primitive enabling multiple threads to
synchronize the beginning of some computation.</p>
<p>When <code>barrier_wait</code> procedure is called by any thread, that thread will block
the execution, until all threads associated with the barrier reach the same
point of execution and also call <code>barrier_wait</code>.</p>
<p>When a barrier is initialized, a <code>thread_count</code> parameter is passed, signifying
the amount of participant threads of the barrier. The barrier also keeps track
of an internal atomic counter. When a thread calls <code>barrier_wait</code>, the internal
counter is incremented. When the internal counter reaches <code>thread_count</code>, it is
reset and all threads waiting on the barrier are unblocked.</p>
<p>This type of synchronization primitive can be used to synchronize "staged"
workloads, where the workload is split into stages, and until all threads have
completed the previous threads, no thread is allowed to start work on the next
stage. In this case, after each stage, a <code>barrier_wait</code> shall be inserted in the
thread procedure.</p>
<p><b>Example</b>:</p>
<pre>THREAD_COUNT :: 4
threads: [THREAD_COUNT]^thread.Thread
sync.barrier_init(barrier, THREAD_COUNT)
for _, i in threads {
	threads[i] = thread.create_and_start(proc(t: ^thread.Thread) {
		// Same messages will be printed together but without any interleaving
		fmt.println("Getting ready!")
		sync.barrier_wait(barrier)
		fmt.println("Off their marks they go!")
	})
}
for t in threads {
	thread.destroy(t)
}
</pre>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#barrier_init">barrier_init</a></li>
<li><a href="/core/sync/#barrier_wait">barrier_wait</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Benaphore"><span><a class="doc-id-link" href="#Benaphore">Benaphore<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L341"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Benaphore :: <span class="keyword-type">struct</span> {
	counter: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a>,
	sema:    <a class="code-typename" href="/core/sync/#Sema">Sema</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Benaphore.</p>
<p>A benaphore is a combination of an atomic variable and a semaphore that can
improve locking efficiency in a no-contention system. Acquiring a benaphore
lock doesn't call into an internal semaphore, if no other thread is in the
middle of a critical section.</p>
<p>Once a lock on a benaphore is acquired by a thread, no other thread is allowed
into any critical sections, associted with the same benaphore, until the lock
is released.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#benaphore_guard">benaphore_guard</a></li>
<li><a href="/core/sync/#benaphore_lock">benaphore_lock</a></li>
<li><a href="/core/sync/#benaphore_try_lock">benaphore_try_lock</a></li>
<li><a href="/core/sync/#benaphore_unlock">benaphore_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Cond"><span><a class="doc-id-link" href="#Cond">Cond<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L417"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Cond :: <span class="keyword-type">struct</span> {
	impl: _Cond,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A condition variable.</p>
<p><code>Cond</code> implements a condition variable, a rendezvous point for threads waiting
for signalling the occurence of an event. Condition variables are used in
conjuction with mutexes to provide a shared access to one or more shared
variable.</p>
<p>A typical usage of condition variable is as follows. A thread that intends to
modify a shared variable shall:</p>
<p>1. Acquire a lock on a mutex.
2. Modify the shared memory.
3. Release the lock.
3. Call <code>cond_signal</code> or <code>cond_broadcast</code>.</p>
<p>A thread that intends to wait on a shared variable shall:</p>
<p>1. Acquire a lock on a mutex.
2. Call <code>cond_wait</code> or <code>cond_wait_with_timeout</code> (will release the mutex).
3. Check the condition and keep waiting in a loop if not satisfied with result.</p>
<p><b>Note</b>: A condition variable must not be copied after first use (e.g., after
waiting on it the first time). This is because, in order to coordinate with
other threads, all threads must watch the same memory address to know when the
lock has been released. Trying to use a copy of the lock at a different memory
address will result in broken and unsafe behavior. For this reason, condition
variables are marked as <code>#no_copy</code>.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#cond_broadcast">cond_broadcast</a></li>
<li><a href="/core/sync/#cond_signal">cond_signal</a></li>
<li><a href="/core/sync/#cond_wait">cond_wait</a></li>
<li><a href="/core/sync/#cond_wait_with_timeout">cond_wait_with_timeout</a></li>
<li><a href="/core/sync/#broadcast">broadcast</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#signal">signal</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Futex"><span><a class="doc-id-link" href="#Futex">Futex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L548"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Futex :: <span class="keyword-type">distinct</span> <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Fast userspace mutual exclusion lock.</p>
<p>Futex is a fast userspace mutual exclusion lock, that uses a pointer to a 32-bit
value as an identifier of the queue of waiting threads. The value pointed to
by that pointer can be used to store extra data.</p>
<p><b>IMPORTANT</b>: A futex must not be copied after first use (e.g., after waiting
on it the first time, or signalling it). This is because, in order to coordinate
with other threads, all threads must watch the same memory address. Trying to
use a copy of the lock at a different memory address will result in broken and
unsafe behavior.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#futex_broadcast">futex_broadcast</a></li>
<li><a href="/core/sync/#futex_signal">futex_signal</a></li>
<li><a href="/core/sync/#futex_wait">futex_wait</a></li>
<li><a href="/core/sync/#futex_wait_with_timeout">futex_wait_with_timeout</a></li>
<li><a href="/core/sync/#broadcast">broadcast</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#signal">signal</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Mutex"><span><a class="doc-id-link" href="#Mutex">Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L39"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Mutex :: <span class="keyword-type">struct</span> {
	impl: _Mutex,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Mutual exclusion lock.</p>
<p>A Mutex is a <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutual exclusion lock</a>
It can be used to prevent more than one thread from entering the critical
section, and thus prevent access to same piece of memory by multiple threads, at
the same time.</p>
<p>Mutex's zero-initializzed value represents an initial, <i>unlocked</i> state.</p>
<p>If another thread tries to acquire the lock, while it's already held (typically
by another thread), the thread's execution will be blocked, until the lock is
released. Code or memory that is "surrounded" by a mutex lock and unlock
operations is said to be "guarded by a mutex".</p>
<p><b>Note</b>: A Mutex must not be copied after first use (e.g., after locking it the
first time). This is because, in order to coordinate with other threads, all
threads must watch the same memory address to know when the lock has been
released. Trying to use a copy of the lock at a different memory address will
result in broken and unsafe behavior. For this reason, Mutexes are marked as
<code>#no_copy</code>.</p>
<p><b>Note</b>: If the current thread attempts to lock a mutex, while it's already
holding another lock, that will cause a trivial case of deadlock. Do not use
<code>Mutex</code> in recursive functions. In case multiple locks by the same thread are
desired, use <code>Recursive_Mutex</code>.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#cond_wait">cond_wait</a></li>
<li><a href="/core/sync/#cond_wait_with_timeout">cond_wait_with_timeout</a></li>
<li><a href="/core/sync/#mutex_guard">mutex_guard</a></li>
<li><a href="/core/sync/#mutex_lock">mutex_lock</a></li>
<li><a href="/core/sync/#mutex_try_lock">mutex_try_lock</a></li>
<li><a href="/core/sync/#mutex_unlock">mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Once"><span><a class="doc-id-link" href="#Once">Once<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L545"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Once :: <span class="keyword-type">struct</span> {
	m:    <a class="code-typename" href="/core/sync/#Mutex">Mutex</a>,
	done: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Once action.</p>
<p><code>Once</code> a synchronization primitive, that only allows a single entry into a
critical section from a single thread.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#once_do_with_data">once_do_with_data</a></li>
<li><a href="/core/sync/#once_do_with_data_contextless">once_do_with_data_contextless</a></li>
<li><a href="/core/sync/#once_do_without_data">once_do_without_data</a></li>
<li><a href="/core/sync/#once_do_without_data_contextless">once_do_without_data_contextless</a></li>
<li><a href="/core/sync/#once_do">once_do</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="One_Shot_Event"><span><a class="doc-id-link" href="#One_Shot_Event">One_Shot_Event<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L722"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">One_Shot_Event :: <span class="keyword-type">struct</span> {
	state: <a class="code-typename" href="/core/sync/#Futex">Futex</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>One-shot event.</p>
<p>A one-shot event is an associated token which is initially not present:</p>
<p>The <code>one_shot_event_wait</code> blocks the current thread until the event
  is made available
The <code>one_shot_event_signal</code> procedure automatically makes the token
  available if its was not already.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#one_shot_event_signal">one_shot_event_signal</a></li>
<li><a href="/core/sync/#one_shot_event_wait">one_shot_event_wait</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Parker"><span><a class="doc-id-link" href="#Parker">Parker<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L645"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Parker :: <span class="keyword-type">struct</span> {
	state: <a class="code-typename" href="/core/sync/#Futex">Futex</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A Parker is an associated token which is initially not present:</p>
<p>The <code>park</code> procedure blocks the current thread unless or until the token
  is available, at which point the token is consumed.
The <code>park_with_timeout</code> procedures works the same as <code>park</code> but only
  blocks for the specified duration.
The <code>unpark</code> procedure automatically makes the token available if it
  was not already.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#park">park</a></li>
<li><a href="/core/sync/#park_with_timeout">park_with_timeout</a></li>
<li><a href="/core/sync/#unpark">unpark</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="RW_Mutex"><span><a class="doc-id-link" href="#RW_Mutex">RW_Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L150"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">RW_Mutex :: <span class="keyword-type">struct</span> {
	impl: _RW_Mutex,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Read-write mutual exclusion lock.</p>
<p>An <code>RW_Mutex</code> is a reader/writer mutual exclusion lock. The lock can be held by
any number of readers or a single writer.</p>
<p>This type of synchronization primitive supports two kinds of lock operations:</p>
<p><span class="doc-list">Exclusive lock (write lock)</span>
<span class="doc-list">Shared lock (read lock)</span></p>
<p>When an exclusive lock is acquired by any thread, all other threads, attempting
to acquire either an exclusive or shared lock, will be blocked from entering the
critical sections associated with the read-write mutex, until the exclusive
owner of the lock releases the lock.</p>
<p>When a shared lock is acquired by any thread, any other thread attempting to
acquire a shared lock will also be able to enter all the critical sections
associated with the read-write mutex. However threads attempting to acquire
an exclusive lock will be blocked from entering those critical sections, until
all shared locks are released.</p>
<p><b>Note</b>: A read-write mutex must not be copied after first use (e.g., after
acquiring a lock). This is because, in order to coordinate with other threads,
all threads must watch the same memory address to know when the lock has been
released. Trying to use a copy of the lock at a different memory address will
result in broken and unsafe behavior. For this reason, mutexes are marked as
<code>#no_copy</code>.</p>
<p><b>Note</b>: A read-write mutex is not recursive. Do not attempt to acquire an
exclusive lock more than once from the same thread, or an exclusive and shared
lock on the same thread. Taking a shared lock multiple times is acceptable.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#rw_mutex_guard">rw_mutex_guard</a></li>
<li><a href="/core/sync/#rw_mutex_lock">rw_mutex_lock</a></li>
<li><a href="/core/sync/#rw_mutex_shared_guard">rw_mutex_shared_guard</a></li>
<li><a href="/core/sync/#rw_mutex_shared_lock">rw_mutex_shared_lock</a></li>
<li><a href="/core/sync/#rw_mutex_shared_unlock">rw_mutex_shared_unlock</a></li>
<li><a href="/core/sync/#rw_mutex_try_lock">rw_mutex_try_lock</a></li>
<li><a href="/core/sync/#rw_mutex_try_shared_lock">rw_mutex_try_shared_lock</a></li>
<li><a href="/core/sync/#rw_mutex_unlock">rw_mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#shared_guard">shared_guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#shared_lock">shared_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#shared_unlock">shared_unlock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_shared_lock">try_shared_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Recursive_Benaphore"><span><a class="doc-id-link" href="#Recursive_Benaphore">Recursive_Benaphore<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L433"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Recursive_Benaphore :: <span class="keyword-type">struct</span> {
	counter:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	owner:     <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	recursion: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a>,
	sema:      <a class="code-typename" href="/core/sync/#Sema">Sema</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Recursive benaphore.</p>
<p>A recursive benaphore is just like a plain benaphore, except it allows
reentrancy into the critical section.</p>
<p>When a lock is acquired on a benaphore, all other threads attempting to
acquire a lock on the same benaphore will be blocked from any critical sections,
associated with the same benaphore.</p>
<p>When a lock is acquired on a benaphore by a thread, that thread is allowed
to acquire another lock on the same benaphore. When a thread has acquired the
lock on a benaphore, the benaphore will stay locked until the thread releases
the lock as many times as it has been locked by the thread.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#recursive_benaphore_guard">recursive_benaphore_guard</a></li>
<li><a href="/core/sync/#recursive_benaphore_lock">recursive_benaphore_lock</a></li>
<li><a href="/core/sync/#recursive_benaphore_try_lock">recursive_benaphore_try_lock</a></li>
<li><a href="/core/sync/#recursive_benaphore_unlock">recursive_benaphore_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Recursive_Mutex"><span><a class="doc-id-link" href="#Recursive_Mutex">Recursive_Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L316"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Recursive_Mutex :: <span class="keyword-type">struct</span> {
	impl: _Recursive_Mutex,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Recursive mutual exclusion lock.</p>
<p>Recurisve mutex is just like a plain mutex, except it allows reentrancy. In
order for a thread to release the mutex for other threads, the mutex needs to
be unlocked as many times, as it was locked.</p>
<p>When a lock is acquired on a recursive mutex, all other threads attempting to
acquire a lock on the same mutex will be blocked from any critical sections,
associated with the same recrusive mutex.</p>
<p>When a lock is acquired on a recursive mutex by a thread, that thread is allowed
to acquire another lock on the same mutex. When a thread has acquired the lock
on a recursive mutex, the recursive mutex will stay locked until the thread
releases the lock as many times as it has been locked by the thread.</p>
<p><b>Note</b>: A recursive mutex must not be copied after first use (e.g., after
acquiring a lock). This is because, in order to coordinate with other threads,
all threads must watch the same memory address to know when the lock has been
released. Trying to use a copy of the lock at a different memory address will
result in broken and unsafe behavior. For this reason, mutexes are marked as
<code>#no_copy</code>.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#recursive_mutex_guard">recursive_mutex_guard</a></li>
<li><a href="/core/sync/#recursive_mutex_lock">recursive_mutex_lock</a></li>
<li><a href="/core/sync/#recursive_mutex_try_lock">recursive_mutex_try_lock</a></li>
<li><a href="/core/sync/#recursive_mutex_unlock">recursive_mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#try_lock">try_lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Sema"><span><a class="doc-id-link" href="#Sema">Sema<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L497"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Sema :: <span class="keyword-type">struct</span> {
	impl: _Sema,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Semaphore.</p>
<p>When waited upon, semaphore blocks until the internal count is greater than
zero, then decrements the internal counter by one. Posting to the semaphore
increases the count by one, or the provided amount.</p>
<p>This type of synchronization primitives can be useful for implementing queues.
The internal counter of the semaphore can be thought of as the amount of items
in the queue. After a data has been pushed to the queue, the thread shall call
<code>sema_post()</code> procedure, increasing the counter. When a thread takes an item
from the queue to do the job, it shall call <code>sema_wait()</code>, waiting on the
semaphore counter to become non-zero and decreasing it, if necessary.</p>
<p><b>Note</b>: A semaphore must not be copied after first use (e.g., after posting
to it). This is because, in order to coordinate with other threads, all threads
must watch the same memory address to know when the lock has been released.
Trying to use a copy of the lock at a different memory address will result in
broken and unsafe behavior. For this reason, semaphores are marked as <code>#no_copy</code>.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#sema_post">sema_post</a></li>
<li><a href="/core/sync/#sema_wait">sema_wait</a></li>
<li><a href="/core/sync/#sema_wait_with_timeout">sema_wait_with_timeout</a></li>
<li><a href="/core/sync/#post">post</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Ticket_Mutex"><span><a class="doc-id-link" href="#Ticket_Mutex">Ticket_Mutex<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L269"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Ticket_Mutex :: <span class="keyword-type">struct</span> {
	ticket:  <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>,
	serving: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Ticket lock.</p>
<p>A ticket lock is a mutual exclusion lock that uses "tickets" to control which
thread is allowed into a critical section.</p>
<p>This synchronization primitive works just like spinlock, except that it implements
a "fairness" guarantee, making sure that each thread gets a roughly equal amount
of entries into the critical section.</p>
<p>This type of synchronization primitive is applicable for short critical sections
in low-contention systems, as it uses a spinlock under the hood.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#ticket_mutex_guard">ticket_mutex_guard</a></li>
<li><a href="/core/sync/#ticket_mutex_lock">ticket_mutex_lock</a></li>
<li><a href="/core/sync/#ticket_mutex_unlock">ticket_mutex_unlock</a></li>
<li><a href="/core/sync/#guard">guard</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#lock">lock</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#unlock">unlock</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Wait_Group"><span><a class="doc-id-link" href="#Wait_Group">Wait_Group<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L29"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Wait_Group :: <span class="keyword-type">struct</span> {
	counter: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	mutex:   <a class="code-typename" href="/core/sync/#Mutex">Mutex</a>,
	cond:    <a class="code-typename" href="/core/sync/#Cond">Cond</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait group.</p>
<p>Wait group is a synchronization primitive used by the waiting thread to wait,
until all working threads finish work.</p>
<p>The waiting thread first sets the number of working threads it will expect to
wait for using <code>wait_group_add</code> call, and start waiting using <code>wait_group_wait</code>
call. When worker threads complete their work, each of them will call
<code>wait_group_done</code>, and after all working threads have called this procedure,
the waiting thread will resume execution.</p>
<p>For the purpose of keeping track whether all working threads have finished their
work, the wait group keeps an internal atomic counter. Initially, the waiting
thread might set it to a certain non-zero amount. When each working thread
completes the work, the internal counter is atomically decremented until it
reaches zero. When it reaches zero, the waiting thread is unblocked. The counter
is not allowed to become negative.</p>
<p><b>Note</b>: Just like any synchronization primitives, a wait group cannot be
copied after first use. See documentation for <code>Mutex</code> or <code>Cond</code>.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/sync/#wait_group_add">wait_group_add</a></li>
<li><a href="/core/sync/#wait_group_done">wait_group_done</a></li>
<li><a href="/core/sync/#wait_group_wait">wait_group_wait</a></li>
<li><a href="/core/sync/#wait_group_wait_with_timeout">wait_group_wait_with_timeout</a></li>
<li><a href="/core/sync/#wait">wait</a>&nbsp;<em>(procedure groups)</em></li>
<li><a href="/core/sync/#wait_with_timeout">wait_with_timeout</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<h2 id="pkg-Constants" class="pkg-header">Constants</h2>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State_Half_Width"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State_Half_Width">Atomic_RW_Mutex_State_Half_Width<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L98"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State_Half_Width :: size_of(Atomic_RW_Mutex_State) * 8 / 2</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State_Is_Writing"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State_Is_Writing">Atomic_RW_Mutex_State_Is_Writing<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L99"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State_Is_Writing :: Atomic_RW_Mutex_State(1)</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State_Reader"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State_Reader">Atomic_RW_Mutex_State_Reader<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L101"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State_Reader :: Atomic_RW_Mutex_State(1) &lt;&lt; Atomic_RW_Mutex_State_Half_Width</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State_Reader_Mask"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State_Reader_Mask">Atomic_RW_Mutex_State_Reader_Mask<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L104"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State_Reader_Mask :: Atomic_RW_Mutex_State(1 &lt;&lt; (Atomic_RW_Mutex_State_Half_Width - 1) - 1) &lt;&lt; Atomic_RW_Mutex_State_Half_Width</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State_Writer"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State_Writer">Atomic_RW_Mutex_State_Writer<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L100"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State_Writer :: Atomic_RW_Mutex_State(1) &lt;&lt; 1</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Atomic_RW_Mutex_State_Writer_Mask"><span><a class="doc-id-link" href="#Atomic_RW_Mutex_State_Writer_Mask">Atomic_RW_Mutex_State_Writer_Mask<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L103"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Atomic_RW_Mutex_State_Writer_Mask :: Atomic_RW_Mutex_State(1 &lt;&lt; (Atomic_RW_Mutex_State_Half_Width - 1) - 1) &lt;&lt; 1</pre>
</div>
</div>
<h2 id="pkg-Variables" class="pkg-header">Variables</h2>
<p class="pkg-empty-section">This section is empty.</p>
<h2 id="pkg-Procedures" class="pkg-header">Procedures</h2>
<div class="pkg-entity">
<h3 id="atomic_add"><span><a class="doc-id-link" href="#atomic_add">atomic_add<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_add :: <a href="/base/intrinsics#atomic_add">intrinsics</a>.atomic_add</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically add a value to the value stored in memory.</p>
<p>This procedure loads a value from memory, adds the specified value to it, and
stores it back as an atomic operation. This operation is an atomic equivalent
of the following:</p>
<pre>dst^ += val

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_add_explicit"><span><a class="doc-id-link" href="#atomic_add_explicit">atomic_add_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_add_explicit :: <a href="/base/intrinsics#atomic_add_explicit">intrinsics</a>.atomic_add_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically add a value to the value stored in memory.</p>
<p>This procedure loads a value from memory, adds the specified value to it, and
stores it back as an atomic operation. This operation is an atomic equivalent
of the following:</p>
<pre>dst^ += val

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_and"><span><a class="doc-id-link" href="#atomic_and">atomic_and<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_and :: <a href="/base/intrinsics#atomic_and">intrinsics</a>.atomic_and</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of AND operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of AND operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ &= val

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_and_explicit"><span><a class="doc-id-link" href="#atomic_and_explicit">atomic_and_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_and_explicit :: <a href="/base/intrinsics#atomic_and_explicit">intrinsics</a>.atomic_and_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of AND operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of AND operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ &= val

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_strong"><span><a class="doc-id-link" href="#atomic_compare_exchange_strong">atomic_compare_exchange_strong<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_strong :: <a href="/base/intrinsics#atomic_compare_exchange_strong">intrinsics</a>.atomic_compare_exchange_strong</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically compare and exchange the value with a memory location.</p>
<p>This procedure checks if the value pointed to by the <code>dst</code> parameter is equal
to <code>old</code>, and if they are, it stores the value <code>new</code> into the memory location,
all done in a single atomic operation. This procedure returns the old value
stored in a memory location and a boolean value signifying whether <code>old</code> was
equal to <code>new</code>.</p>
<p>This procedure is an atomic equivalent of the following operation:</p>
<pre>old_dst := dst^
if old_dst == old {
	dst^ = new
	return old_dst, true
} else {
	return old_dst, false
}

</pre>
<p>The strong version of compare exchange always returns true, when the returned
old value stored in location pointed to by <code>dst</code> and the <code>old</code> parameter are
equal.</p>
<p>Atomic compare exchange has two memory orderings: One is for the
read-modify-write operation, if the comparison succeeds, and the other is for
the load operation, if the comparison fails. The memory ordering for both of
of these operations is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_strong_explicit"><span><a class="doc-id-link" href="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_strong_explicit :: <a href="/base/intrinsics#atomic_compare_exchange_strong_explicit">intrinsics</a>.atomic_compare_exchange_strong_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically compare and exchange the value with a memory location.</p>
<p>This procedure checks if the value pointed to by the <code>dst</code> parameter is equal
to <code>old</code>, and if they are, it stores the value <code>new</code> into the memory location,
all done in a single atomic operation. This procedure returns the old value
stored in a memory location and a boolean value signifying whether <code>old</code> was
equal to <code>new</code>.</p>
<p>This procedure is an atomic equivalent of the following operation:</p>
<pre>old_dst := dst^
if old_dst == old {
	dst^ = new
	return old_dst, true
} else {
	return old_dst, false
}

</pre>
<p>The strong version of compare exchange always returns true, when the returned
old value stored in location pointed to by <code>dst</code> and the <code>old</code> parameter are
equal.</p>
<p>Atomic compare exchange has two memory orderings: One is for the
read-modify-write operation, if the comparison succeeds, and the other is for
the load operation, if the comparison fails. The memory ordering for these
operations is as specified by <code>success</code> and <code>failure</code> parameters respectively.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_weak"><span><a class="doc-id-link" href="#atomic_compare_exchange_weak">atomic_compare_exchange_weak<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_weak :: <a href="/base/intrinsics#atomic_compare_exchange_weak">intrinsics</a>.atomic_compare_exchange_weak</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically compare and exchange the value with a memory location.</p>
<p>This procedure checks if the value pointed to by the <code>dst</code> parameter is equal
to <code>old</code>, and if they are, it stores the value <code>new</code> into the memory location,
all done in a single atomic operation. This procedure returns the old value
stored in a memory location and a boolean value signifying whether <code>old</code> was
equal to <code>new</code>.</p>
<p>This procedure is an atomic equivalent of the following operation:</p>
<pre>old_dst := dst^
if old_dst == old {
	// may return false here
	dst^ = new
	return old_dst, true
} else {
	return old_dst, false
}

</pre>
<p>The weak version of compare exchange may return false, even if <code>dst^ == old</code>.
On some platforms running weak compare exchange in a loop is faster than a
strong version.</p>
<p>Atomic compare exchange has two memory orderings: One is for the
read-modify-write operation, if the comparison succeeds, and the other is for
the load operation, if the comparison fails. The memory ordering for both
of these operations is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_weak_explicit"><span><a class="doc-id-link" href="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_weak_explicit :: <a href="/base/intrinsics#atomic_compare_exchange_weak_explicit">intrinsics</a>.atomic_compare_exchange_weak_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically compare and exchange the value with a memory location.</p>
<p>This procedure checks if the value pointed to by the <code>dst</code> parameter is equal
to <code>old</code>, and if they are, it stores the value <code>new</code> into the memory location,
all done in a single atomic operation. This procedure returns the old value
stored in a memory location and a boolean value signifying whether <code>old</code> was
equal to <code>new</code>.</p>
<p>This procedure is an atomic equivalent of the following operation:</p>
<pre>old_dst := dst^
if old_dst == old {
	// may return false here
	dst^ = new
	return old_dst, true
} else {
	return old_dst, false
}

</pre>
<p>The weak version of compare exchange may return false, even if <code>dst^ == old</code>.
On some platforms running weak compare exchange in a loop is faster than a
strong version.</p>
<p>Atomic compare exchange has two memory orderings: One is for the
read-modify-write operation, if the comparison succeeds, and the other is for
the load operation, if the comparison fails. The memory ordering for these
operations is as specified by the <code>success</code> and <code>failure</code> parameters
respectively.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_cond_broadcast"><span><a class="doc-id-link" href="#atomic_cond_broadcast">atomic_cond_broadcast<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L314"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_cond_broadcast :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Atomic_Cond">Atomic_Cond</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_cond_signal"><span><a class="doc-id-link" href="#atomic_cond_signal">atomic_cond_signal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L309"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_cond_signal :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Atomic_Cond">Atomic_Cond</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_cond_wait"><span><a class="doc-id-link" href="#atomic_cond_wait">atomic_cond_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L292"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_cond_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Atomic_Cond">Atomic_Cond</a>, m: ^<a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_cond_wait_with_timeout"><span><a class="doc-id-link" href="#atomic_cond_wait_with_timeout">atomic_cond_wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L300"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_cond_wait_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Atomic_Cond">Atomic_Cond</a>, m: ^<a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) -> (ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_exchange"><span><a class="doc-id-link" href="#atomic_exchange">atomic_exchange<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_exchange :: <a href="/base/intrinsics#atomic_exchange">intrinsics</a>.atomic_exchange</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically exchange the value in a memory location, with the specified value.</p>
<p>This procedure loads a value from the specified memory location, and stores the
specified value into that memory location. Then the loaded value is returned,
all done in a single atomic operation. This operation is an atomic equivalent
of the following:</p>
<pre>tmp := dst^
dst^ = val
return tmp

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_exchange_explicit"><span><a class="doc-id-link" href="#atomic_exchange_explicit">atomic_exchange_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_exchange_explicit :: <a href="/base/intrinsics#atomic_exchange_explicit">intrinsics</a>.atomic_exchange_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically exchange the value in a memory location, with the specified value.</p>
<p>This procedure loads a value from the specified memory location, and stores the
specified value into that memory location. Then the loaded value is returned,
all done in a single atomic operation. This operation is an atomic equivalent
of the following:</p>
<pre>tmp := dst^
dst^ = val
return tmp

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_load"><span><a class="doc-id-link" href="#atomic_load">atomic_load<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_load :: <a href="/base/intrinsics#atomic_load">intrinsics</a>.atomic_load</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically load a value from memory.</p>
<p>This procedure loads a value from a memory location in such a way that the
received value is not a partial read. The memory ordering of this operation is
sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_load_explicit"><span><a class="doc-id-link" href="#atomic_load_explicit">atomic_load_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_load_explicit :: <a href="/base/intrinsics#atomic_load_explicit">intrinsics</a>.atomic_load_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically load a value from memory with explicit memory ordering.</p>
<p>This procedure loads a value from a memory location in such a way that the
received value is not a partial read. The memory ordering of this operation
is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_mutex_guard"><span><a class="doc-id-link" href="#atomic_mutex_guard">atomic_mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L91"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">if atomic_mutex_guard(&m) {
	...
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_mutex_lock"><span><a class="doc-id-link" href="#atomic_mutex_lock">atomic_mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L21"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_mutex_lock locks m</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_mutex_try_lock"><span><a class="doc-id-link" href="#atomic_mutex_try_lock">atomic_mutex_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L79"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_mutex_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_mutex_try_lock tries to lock m, will return true on success, and false on failure</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_mutex_unlock"><span><a class="doc-id-link" href="#atomic_mutex_unlock">atomic_mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L61"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Mutex">Atomic_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_mutex_unlock unlocks m</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_nand"><span><a class="doc-id-link" href="#atomic_nand">atomic_nand<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_nand :: <a href="/base/intrinsics#atomic_nand">intrinsics</a>.atomic_nand</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of NAND operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of NAND operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ = ~(dst^ & val)

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_nand_explicit"><span><a class="doc-id-link" href="#atomic_nand_explicit">atomic_nand_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_nand_explicit :: <a href="/base/intrinsics#atomic_nand_explicit">intrinsics</a>.atomic_nand_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of NAND operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of NAND operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ = ~(dst^ & val)

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_or"><span><a class="doc-id-link" href="#atomic_or">atomic_or<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_or :: <a href="/base/intrinsics#atomic_or">intrinsics</a>.atomic_or</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of OR operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of OR operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ |= val

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_or_explicit"><span><a class="doc-id-link" href="#atomic_or_explicit">atomic_or_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_or_explicit :: <a href="/base/intrinsics#atomic_or_explicit">intrinsics</a>.atomic_or_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of OR operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of OR operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ |= val

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_recursive_mutex_guard"><span><a class="doc-id-link" href="#atomic_recursive_mutex_guard">atomic_recursive_mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L277"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_recursive_mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">if atomic_recursive_mutex_guard(&m) {
	...
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_recursive_mutex_lock"><span><a class="doc-id-link" href="#atomic_recursive_mutex_lock">atomic_recursive_mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L231"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_recursive_mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_recursive_mutex_try_lock"><span><a class="doc-id-link" href="#atomic_recursive_mutex_try_lock">atomic_recursive_mutex_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L256"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_recursive_mutex_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_recursive_mutex_unlock"><span><a class="doc-id-link" href="#atomic_recursive_mutex_unlock">atomic_recursive_mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L241"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_recursive_mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_guard"><span><a class="doc-id-link" href="#atomic_rw_mutex_guard">atomic_rw_mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L201"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">if atomic_rw_mutex_guard(&m) {
	...
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_lock"><span><a class="doc-id-link" href="#atomic_rw_mutex_lock">atomic_rw_mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L120"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_rw_mutex_lock locks rw for writing (with a single writer)
If the mutex is already locked for reading or writing, the mutex blocks until the mutex is available.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_shared_guard"><span><a class="doc-id-link" href="#atomic_rw_mutex_shared_guard">atomic_rw_mutex_shared_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L213"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_shared_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">if atomic_rw_mutex_shared_guard(&m) {
	...
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_shared_lock"><span><a class="doc-id-link" href="#atomic_rw_mutex_shared_lock">atomic_rw_mutex_shared_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L151"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_shared_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_rw_mutex_shared_lock locks rw for reading (with arbitrary number of readers)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_shared_unlock"><span><a class="doc-id-link" href="#atomic_rw_mutex_shared_unlock">atomic_rw_mutex_shared_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L167"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_shared_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_rw_mutex_shared_unlock unlocks rw for reading (with arbitrary number of readers)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_try_lock"><span><a class="doc-id-link" href="#atomic_rw_mutex_try_lock">atomic_rw_mutex_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L137"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_rw_mutex_try_lock tries to lock rw for writing (with a single writer)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_try_shared_lock"><span><a class="doc-id-link" href="#atomic_rw_mutex_try_shared_lock">atomic_rw_mutex_try_shared_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L177"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_try_shared_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_rw_mutex_try_shared_lock tries to lock rw for reading (with arbitrary number of readers)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_rw_mutex_unlock"><span><a class="doc-id-link" href="#atomic_rw_mutex_unlock">atomic_rw_mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L131"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_rw_mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#Atomic_RW_Mutex">Atomic_RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>atomic_rw_mutex_unlock unlocks rw for writing (with a single writer)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_sema_post"><span><a class="doc-id-link" href="#atomic_sema_post">atomic_sema_post<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L327"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_sema_post :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: ^<a class="code-typename" href="/core/sync/#Atomic_Sema">Atomic_Sema</a>, count: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 1) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_sema_wait"><span><a class="doc-id-link" href="#atomic_sema_wait">atomic_sema_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L336"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_sema_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: ^<a class="code-typename" href="/core/sync/#Atomic_Sema">Atomic_Sema</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_sema_wait_with_timeout"><span><a class="doc-id-link" href="#atomic_sema_wait_with_timeout">atomic_sema_wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin#L349"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">atomic_sema_wait_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: ^<a class="code-typename" href="/core/sync/#Atomic_Sema">Atomic_Sema</a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_signal_fence"><span><a class="doc-id-link" href="#atomic_signal_fence">atomic_signal_fence<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_signal_fence :: <a href="/base/intrinsics#atomic_signal_fence">intrinsics</a>.atomic_signal_fence</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Establish memory ordering between a current thread and a signal handler.</p>
<p>This procedure establishes memory ordering between a thread and a signal
handler, that run on the same thread, without an associated atomic operation.
This procedure is equivalent to <code>atomic_thread_fence</code>, except it doesn't
issue any CPU instructions for memory ordering.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_store"><span><a class="doc-id-link" href="#atomic_store">atomic_store<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_store :: <a href="/base/intrinsics#atomic_store">intrinsics</a>.atomic_store</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically store a value into memory.</p>
<p>This procedure stores a value to a memory location in such a way that no other
thread is able to see partial reads. This operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_store_explicit"><span><a class="doc-id-link" href="#atomic_store_explicit">atomic_store_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_store_explicit :: <a href="/base/intrinsics#atomic_store_explicit">intrinsics</a>.atomic_store_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically store a value into memory with explicit memory ordering.</p>
<p>This procedure stores a value to a memory location in such a way that no other
thread is able to see partial reads. The memory ordering of this operation is
as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_sub"><span><a class="doc-id-link" href="#atomic_sub">atomic_sub<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_sub :: <a href="/base/intrinsics#atomic_sub">intrinsics</a>.atomic_sub</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically subtract a value from the value stored in memory.</p>
<p>This procedure loads a value from memory, subtracts the specified value from it,
and stores the result back as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ -= val

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_sub_explicit"><span><a class="doc-id-link" href="#atomic_sub_explicit">atomic_sub_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_sub_explicit :: <a href="/base/intrinsics#atomic_sub_explicit">intrinsics</a>.atomic_sub_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically subtract a value from the value stored in memory.</p>
<p>This procedure loads a value from memory, subtracts the specified value from it,
and stores the result back as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ -= val

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_thread_fence"><span><a class="doc-id-link" href="#atomic_thread_fence">atomic_thread_fence<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_thread_fence :: <a href="/base/intrinsics#atomic_thread_fence">intrinsics</a>.atomic_thread_fence</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Establish memory ordering.</p>
<p>This procedure establishes memory ordering, without an associated atomic
operation.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_xor"><span><a class="doc-id-link" href="#atomic_xor">atomic_xor<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_xor :: <a href="/base/intrinsics#atomic_xor">intrinsics</a>.atomic_xor</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of XOR operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of XOR operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ ~= val

</pre>
<p>The memory ordering of this operation is sequentially-consistent.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_xor_explicit"><span><a class="doc-id-link" href="#atomic_xor_explicit">atomic_xor_explicit<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_xor_explicit :: <a href="/base/intrinsics#atomic_xor_explicit">intrinsics</a>.atomic_xor_explicit</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Atomically replace the memory location with the result of XOR operation with
the specified value.</p>
<p>This procedure loads a value from memory, calculates the result of XOR operation
between the loaded value and the specified value, and stores it back into the
same memory location as an atomic operation. This operation is an atomic
equivalent of the following:</p>
<pre>dst^ ~= val

</pre>
<p>The memory ordering of this operation is as specified by the <code>order</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="auto_reset_event_signal"><span><a class="doc-id-link" href="#auto_reset_event_signal">auto_reset_event_signal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L229"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">auto_reset_event_signal :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (e: ^<a class="code-typename" href="/core/sync/#Auto_Reset_Event">Auto_Reset_Event</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Signal an auto-reset event.</p>
<p>This procedure signals an auto-reset event, waking up exactly one waiting
thread.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="auto_reset_event_wait"><span><a class="doc-id-link" href="#auto_reset_event_wait">auto_reset_event_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L249"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">auto_reset_event_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (e: ^<a class="code-typename" href="/core/sync/#Auto_Reset_Event">Auto_Reset_Event</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait on an auto-reset event.</p>
<p>This procedure blocks the execution of the current thread, until the event is
signalled by another thread.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="barrier_init"><span><a class="doc-id-link" href="#barrier_init">barrier_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L168"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">barrier_init :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Barrier">Barrier</a>, thread_count: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a barrier.</p>
<p>This procedure initializes the barrier for the specified amount of participant
threads.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="barrier_wait"><span><a class="doc-id-link" href="#barrier_wait">barrier_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L184"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">barrier_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Barrier">Barrier</a>) -> (is_leader: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Block the current thread until all threads have rendezvoused.</p>
<p>This procedure blocks the execution of the current thread, until all threads
have reached the same point in the execution of the thread proc. Multiple calls
to <code>barrier_wait</code> are allowed within the thread procedure.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="benaphore_guard"><span><a class="doc-id-link" href="#benaphore_guard">benaphore_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L413"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">benaphore_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Benaphore">Benaphore</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the current scope with a lock on a benaphore.</p>
<p>This procedure acquires a lock on a benaphore. The lock is automatically
released at the end of callee's scope. If the benaphore was already locked, this
procedure also blocks until the lock can be acquired.</p>
<p>When a lock has been acquired, all threads attempting to acquire a lock will be
blocked from entering any critical sections associated with the same benaphore,
until the lock is released.</p>
<p>This procedure always returns <code>true</code>. This makes it easy to define a critical
section by putting the function inside the <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if benaphore_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="benaphore_lock"><span><a class="doc-id-link" href="#benaphore_lock">benaphore_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L357"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">benaphore_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Benaphore">Benaphore</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire a lock on a benaphore.</p>
<p>This procedure acquires a lock on the specified benaphore. If the lock on a
benaphore is already held, this procedure also blocks the execution of the
current thread, until the lock could be acquired.</p>
<p>Once a lock is acquired, all threads attempting to take a lock will be blocked
from entering any critical sections associated with the same benaphore, until
until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="benaphore_try_lock"><span><a class="doc-id-link" href="#benaphore_try_lock">benaphore_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L374"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">benaphore_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Benaphore">Benaphore</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Try to acquire a lock on a benaphore.</p>
<p>This procedure tries to acquire a lock on the specified benaphore. If it was
already locked, then the returned value is <code>false</code>, otherwise the lock is
acquired and the procedure returns <code>true</code>.</p>
<p>If the lock is acquired, all threads that attempt to acquire a lock will be
blocked from entering any critical sections associated with the same benaphore,
until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="benaphore_unlock"><span><a class="doc-id-link" href="#benaphore_unlock">benaphore_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L386"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">benaphore_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Benaphore">Benaphore</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release a lock on a benaphore.</p>
<p>This procedure releases a lock on the specified benaphore. If any of the threads
are waiting on the lock, exactly one thread is allowed into a critical section
associated with the same benaphore.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="cond_broadcast"><span><a class="doc-id-link" href="#cond_broadcast">cond_broadcast<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L473"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">cond_broadcast :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Cond">Cond</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wake up all threads that wait on a condition variable.</p>
<p>This procedure causes all threads waiting on the condition variable to wake up.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="cond_signal"><span><a class="doc-id-link" href="#cond_signal">cond_signal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L464"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">cond_signal :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Cond">Cond</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wake up one thread that waits on a condition variable.</p>
<p>This procedure causes exactly one thread waiting on the condition variable to
wake up.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="cond_wait"><span><a class="doc-id-link" href="#cond_wait">cond_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L433"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">cond_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Cond">Cond</a>, m: ^<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait until the condition variable is signalled and release the associated mutex.</p>
<p>This procedure blocks the current thread until the specified condition variable
is signalled, or until a spurious wakeup occurs. In addition, if the condition
has been signalled, this procedure releases the lock on the specified mutex.</p>
<p>The mutex must be held by the calling thread, before calling the procedure.</p>
<p><b>Note</b>: This procedure can return on a spurious wake-up, even if the condition
variable was not signalled by a thread.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="cond_wait_with_timeout"><span><a class="doc-id-link" href="#cond_wait_with_timeout">cond_wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L451"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">cond_wait_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (c: ^<a class="code-typename" href="/core/sync/#Cond">Cond</a>, m: ^<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait until the condition variable is signalled or timeout is reached and release
the associated mutex.</p>
<p>This procedure blocks the current thread until the specified condition variable
is signalled, a timeout is reached, or until a spurious wakeup occurs. In
addition, if the condition has been signalled, this procedure releases the
lock on the specified mutex.</p>
<p>If the timeout was reached, this procedure returns <code>false</code>. Otherwise it returns
<code>true</code>.</p>
<p>Before this procedure is called the mutex must be held by the calling thread.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="cpu_relax"><span><a class="doc-id-link" href="#cpu_relax">cpu_relax<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">cpu_relax :: <a href="/base/intrinsics#cpu_relax">intrinsics</a>.cpu_relax</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>This procedure may lower CPU consumption or yield to a hyperthreaded twin
processor. It's exact function is architecture specific, but the intent is to
say that you're not doing much on a CPU.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="current_thread_id"><span><a class="doc-id-link" href="#current_thread_id">current_thread_id<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L8"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">current_thread_id :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> () -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Obtain the current thread ID.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="futex_broadcast"><span><a class="doc-id-link" href="#futex_broadcast">futex_broadcast<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L596"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">futex_broadcast :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (f: ^<a class="code-typename" href="/core/sync/#Futex">Futex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wake up multiple threads waiting on a futex.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="futex_signal"><span><a class="doc-id-link" href="#futex_signal">futex_signal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L589"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">futex_signal :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (f: ^<a class="code-typename" href="/core/sync/#Futex">Futex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wake up a single thread waiting on a futex.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="futex_wait"><span><a class="doc-id-link" href="#futex_wait">futex_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L557"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">futex_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (f: ^<a class="code-typename" href="/core/sync/#Futex">Futex</a>, expected: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Sleep if the futex contains the expected value until it's signalled.</p>
<p>If the value of the futex is <code>expected</code>, this procedure blocks the execution of
the current thread, until the futex is woken up, or until a spurious wakeup
occurs.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="futex_wait_with_timeout"><span><a class="doc-id-link" href="#futex_wait_with_timeout">futex_wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L575"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">futex_wait_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (f: ^<a class="code-typename" href="/core/sync/#Futex">Futex</a>, expected: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Sleep if the futex contains the expected value until it's signalled or the
timeout is reached.</p>
<p>If the value of the futex is <code>expected</code>, this procedure blocks the execution of
the current thread, until the futex is signalled, a timeout is reached, or
until a spurious wakeup occurs.</p>
<p>This procedure returns <code>false</code> if the timeout was reached, <code>true</code> otherwise.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_guard"><span><a class="doc-id-link" href="#mutex_guard">mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L112"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the current scope with a lock on a mutex.</p>
<p>This procedure acquires a mutex lock. The lock is automatically released
at the end of callee's scope. If the mutex was already locked, this procedure
also blocks until the lock can be acquired.</p>
<p>When a lock has been acquired, all threads attempting to acquire a lock will be
blocked from entering any critical sections associated with the mutex, until
the lock is released.</p>
<p>This procedure always returns <code>true</code>. This makes it easy to define a critical
section by putting the function inside the <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if mutex_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_lock"><span><a class="doc-id-link" href="#mutex_lock">mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L57"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire a lock on a mutex.</p>
<p>This procedure acquires a lock with the specified mutex. If the mutex has been
already locked by any thread, this procedure also blocks until the lock can be
acquired.</p>
<p>Once the lock is acquired, all other threads that attempt to acquire a lock will
be blocked from entering any critical sections associated with the same mutex,
until the the lock is released.</p>
<p><b>Note</b>: If the mutex is already locked by the current thread, a call to this
procedure will block indefinately. Do not use this in recursive procedures.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_try_lock"><span><a class="doc-id-link" href="#mutex_try_lock">mutex_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L87"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Try to acquire a lock on a mutex.</p>
<p>This procedure tries to acquire a lock on the specified mutex. If it was already
locked, then the returned value is <code>false</code>, otherwise the lock is acquired and
the procedure returns <code>true</code>.</p>
<p>If the lock is acquired, all threads that attempt to acquire a lock will be
blocked from entering any critical sections associated with the same mutex,
until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_unlock"><span><a class="doc-id-link" href="#mutex_unlock">mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L72"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release a lock on a mutex.</p>
<p>This procedure releases the lock associated with the specified mutex. If the
mutex was not locked, this operation is a no-op.</p>
<p>When the current thread, that holds a lock to the mutex calls <code>mutex_unlock</code>,
this allows one other thread waiting on the mutex to enter any critical sections
associated with the mutex. If there are no threads waiting on the mutex, the
critical sections will remain open.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="once_do_with_data"><span><a class="doc-id-link" href="#once_do_with_data">once_do_with_data<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L602"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">once_do_with_data :: <span class="keyword-type">proc</span>(o: ^<a class="code-typename" href="/core/sync/#Once">Once</a>, fn: <span class="keyword-type">proc</span>(data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>), data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Call a function with data once.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="once_do_with_data_contextless"><span><a class="doc-id-link" href="#once_do_with_data_contextless">once_do_with_data_contextless<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L620"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">once_do_with_data_contextless :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (o: ^<a class="code-typename" href="/core/sync/#Once">Once</a>, fn: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>), data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Call a contextless function with data once.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="once_do_without_data"><span><a class="doc-id-link" href="#once_do_without_data">once_do_without_data<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L566"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">once_do_without_data :: <span class="keyword-type">proc</span>(o: ^<a class="code-typename" href="/core/sync/#Once">Once</a>, fn: <span class="keyword-type">proc</span>()) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Call a function with no data once.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="once_do_without_data_contextless"><span><a class="doc-id-link" href="#once_do_without_data_contextless">once_do_without_data_contextless<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L584"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">once_do_without_data_contextless :: <span class="keyword-type">proc</span>(o: ^<a class="code-typename" href="/core/sync/#Once">Once</a>, fn: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> ()) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Call a contextless function with no data once.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="one_shot_event_signal"><span><a class="doc-id-link" href="#one_shot_event_signal">one_shot_event_signal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L741"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">one_shot_event_signal :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (e: ^<a class="code-typename" href="/core/sync/#One_Shot_Event">One_Shot_Event</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Make event available.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="one_shot_event_wait"><span><a class="doc-id-link" href="#one_shot_event_wait">one_shot_event_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L732"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">one_shot_event_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (e: ^<a class="code-typename" href="/core/sync/#One_Shot_Event">One_Shot_Event</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Block until the event is made available.</p>
<p>This procedure blocks the execution of the current thread, until the event is
made available.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="park"><span><a class="doc-id-link" href="#park">park<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L662"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">park :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (p: ^<a class="code-typename" href="/core/sync/#Parker">Parker</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Blocks until the token is available.</p>
<p>This procedure blocks the execution of the current thread, until a token is
made available.</p>
<p><b>Note</b>: This procedure assumes this is only called by the thread that owns
the Parker.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="park_with_timeout"><span><a class="doc-id-link" href="#park_with_timeout">park_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L683"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">park_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (p: ^<a class="code-typename" href="/core/sync/#Parker">Parker</a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Blocks until the token is available with timeout.</p>
<p>This procedure blocks the execution of the current thread until a token is made
available, or until the timeout has expired, whatever happens first.</p>
<p><b>Note</b>: This procedure assumes this is only called by the thread that owns
the Parker.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_benaphore_guard"><span><a class="doc-id-link" href="#recursive_benaphore_guard">recursive_benaphore_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L534"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_benaphore_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Recursive_Benaphore">Recursive_Benaphore</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the current scope with a recursive benaphore.</p>
<p>This procedure acquires a lock on the specified recursive benaphores and
automatically releases it at the end of the callee's scope. If the recursive
benaphore was already held by a another thread, this procedure also blocks until
the lock can be acquired.</p>
<p>When the lock is acquired all other threads attempting to take a lock will be
blocked from entering any critical sections associated with the same benaphore,
until the lock is released.</p>
<p>This procedure always returns <code>true</code>, which makes it easy to define a critical
section by calling this procedure inside an <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if recursive_benaphore_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_benaphore_lock"><span><a class="doc-id-link" href="#recursive_benaphore_lock">recursive_benaphore_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L450"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_benaphore_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Recursive_Benaphore">Recursive_Benaphore</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire a lock on a recursive benaphore.</p>
<p>This procedure acquires a lock on a recursive benaphore. If the benaphore is
held by another thread, this function blocks until the lock can be acquired.</p>
<p>Once a lock is acquired, all other threads attempting to acquire a lock will
be blocked from entering any critical sections associated with the same
recursive benaphore, until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_benaphore_try_lock"><span><a class="doc-id-link" href="#recursive_benaphore_try_lock">recursive_benaphore_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L475"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_benaphore_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Recursive_Benaphore">Recursive_Benaphore</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Try to acquire a lock on a recursive benaphore.</p>
<p>This procedure attempts to acquire a lock on recursive benaphore. If the
benaphore is already held by a different thread, this procedure returns <code>false</code>.
Otherwise the lock is acquired and the procedure returns <code>true</code>.</p>
<p>If the lock is acquired, all other threads attempting to acquire a lock will
be blocked from entering any critical sections assciated with the same recursive
benaphore, until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_benaphore_unlock"><span><a class="doc-id-link" href="#recursive_benaphore_unlock">recursive_benaphore_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L496"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_benaphore_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (b: ^<a class="code-typename" href="/core/sync/#Recursive_Benaphore">Recursive_Benaphore</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release a lock on a recursive benaphore.</p>
<p>This procedure releases a lock on the specified recursive benaphore. It also
causes the critical sections associated with the same benaphore, to become open
for other threads for entering.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_mutex_guard"><span><a class="doc-id-link" href="#recursive_mutex_guard">recursive_mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L383"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Recursive_Mutex">Recursive_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the scope with a recursive mutex lock.</p>
<p>This procedure acquires a lock on the specified recursive mutex and
automatically releases it at the end of the callee's scope. If the recursive
mutex was already held by a another thread, this procedure also blocks until the
lock can be acquired.</p>
<p>When the lock is acquired all other threads attempting to take a lock will be
blocked from entering any critical sections associated with the same mutex,
until the lock is released.</p>
<p>This procedure always returns <code>true</code>, which makes it easy to define a critical
section by calling this procedure inside an <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if recursive_mutex_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_mutex_lock"><span><a class="doc-id-link" href="#recursive_mutex_lock">recursive_mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L331"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Recursive_Mutex">Recursive_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire a lock on a recursive mutex.</p>
<p>This procedure acquires a lock on the specified recursive mutex. If the lock is
acquired by a different thread, this procedure also blocks until the lock can be
acquired.</p>
<p>When the lock is acquired, all other threads attempting to acquire a lock will
be blocked from entering any critical sections associated with the same mutex,
until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_mutex_try_lock"><span><a class="doc-id-link" href="#recursive_mutex_try_lock">recursive_mutex_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L357"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_mutex_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Recursive_Mutex">Recursive_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Try to acquire a lock on a recursive mutex.</p>
<p>This procedure attempts to acquire a lock on the specified recursive mutex. If
the recursive mutex is locked by other threads, this procedure returns <code>false</code>.
Otherwise it locks the mutex and returns <code>true</code>.</p>
<p>If the lock is acquired, all other threads attempting to obtain a lock will be
blocked from entering any critical sections associated with the same mutex,
until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="recursive_mutex_unlock"><span><a class="doc-id-link" href="#recursive_mutex_unlock">recursive_mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L342"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recursive_mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Recursive_Mutex">Recursive_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release a lock on a recursive mutex.</p>
<p>This procedure releases a lock on the specified recursive mutex. It also causes
the critical sections associated with the same mutex, to become open for other
threads for entering.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_guard"><span><a class="doc-id-link" href="#rw_mutex_guard">rw_mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L261"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the current scope with an exclusive lock on a read-write mutex.</p>
<p>This procedure acquires an exclusive lock on the specified read-write mutex.
This procedure automatically releases the lock at the end of the callee's scope.
If the mutex was already locked by readers or a writer, this procedure blocks,
until a lock can be acquired.</p>
<p>When an exclusive lock is acquired, all other threads attempting to acquire an
exclusive lock will be blocked from entering any critical sections associated
with the same read-write mutex, until the exclusive lock is released.</p>
<p>This procedure always returns <code>true</code>, which makes it easy to define a critical
section by running this procedure inside an <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if rw_mutex_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_lock"><span><a class="doc-id-link" href="#rw_mutex_lock">rw_mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L165"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire an exclusive lock.</p>
<p>This procedure acquires an exclusive lock on the specified read-write mutex. If
the lock is already held by any thread, this procedure also blocks until the
lock can be acquired.</p>
<p>After a lock has been acquired, any thread attempting to acquire any lock
will be blocked from entering any critical sections associated with the same
read-write mutex, until the exclusive lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_shared_guard"><span><a class="doc-id-link" href="#rw_mutex_shared_guard">rw_mutex_shared_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L288"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_shared_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the current scope with a shared lock on a read-write mutex.</p>
<p>This procedure acquires a shared lock on the specified read-write mutex. This
procedure automatically releases the lock at the end of the callee's scope. If
the mutex already has an associated exclusive lock, this procedure blocks, until
a lock can be acquired.</p>
<p>When a shared lock is obtained, all other threads attempting to obtain an
exclusive lock will be blocked from any critical sections, associated with the
same read-write mutex, until all shared locks are released.</p>
<p>This procedure always returns <code>true</code>, which makes it easy to define a critical
section by running this procedure inside an <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if rw_mutex_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_shared_lock"><span><a class="doc-id-link" href="#rw_mutex_shared_lock">rw_mutex_shared_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L209"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_shared_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire a shared lock on a read-write mutex.</p>
<p>This procedure acquires a shared lock on the specified read-write mutex. If the
mutex already has an exclusive lock held, this procedure also blocks until the
lock can be acquired.</p>
<p>After the shared lock is obtained, all threads attempting to acquire an
exclusive lock will be blocked from entering any critical sections associated
with the same read-write mutex, until all shared locks associated with the
specified read-write mutex are released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_shared_unlock"><span><a class="doc-id-link" href="#rw_mutex_shared_unlock">rw_mutex_shared_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L220"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_shared_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release the shared lock on a read-write mutex.</p>
<p>This procedure releases shared lock on the specified read-write mutex. When all
shared locks are released, all critical sections associated with the same
read-write mutex become open to other threads.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_try_lock"><span><a class="doc-id-link" href="#rw_mutex_try_lock">rw_mutex_try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L193"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_try_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Try to acquire an exclusive lock on a read-write mutex.</p>
<p>This procedure tries to acquire an exclusive lock on the specified read-write
mutex. If the mutex was already locked, the procedure returns <code>false</code>. Otherwise
it acquires the exclusive lock and returns <code>true</code>.</p>
<p>If the lock has been acquired, all threads attempting to acquire any lock
will be blocked from entering any critical sections associated with the same
read-write mutex, until the exclusive locked is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_try_shared_lock"><span><a class="doc-id-link" href="#rw_mutex_try_shared_lock">rw_mutex_try_shared_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L235"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_try_shared_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Try to acquire a shared lock on a read-write mutex.</p>
<p>This procedure attempts to acquire a lock on the specified read-write mutex. If
the mutex already has an exclusive lock held, this procedure returns <code>false</code>.
Otherwise, it acquires the lock on the mutex and returns <code>true</code>.</p>
<p>If the shared lock has been acquired, it causes all threads attempting to
acquire the exclusive lock to be blocked from entering any critical sections
associated with the same read-write mutex, until all shared locks are released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rw_mutex_unlock"><span><a class="doc-id-link" href="#rw_mutex_unlock">rw_mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L178"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rw_mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (rw: ^<a class="code-typename" href="/core/sync/#RW_Mutex">RW_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release an exclusive lock.</p>
<p>This procedure releases an exclusive lock associated with the specified
read-write mutex.</p>
<p>When the exclusive lock is released, all critical sections, associated with the
same read-write mutex, become open to other threads.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="sema_post"><span><a class="doc-id-link" href="#sema_post">sema_post<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L508"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">sema_post :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: ^<a class="code-typename" href="/core/sync/#Sema">Sema</a>, count: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 1) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Increment the internal counter on a semaphore by the specified amount.</p>
<p>This procedure increments the internal counter of the semaphore. If any of the
threads were waiting on the semaphore, up to <code>count</code> of threads will continue
the execution and enter the critical section.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="sema_wait"><span><a class="doc-id-link" href="#sema_wait">sema_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L519"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">sema_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: ^<a class="code-typename" href="/core/sync/#Sema">Sema</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait on a semaphore until the internal counter is non-zero.</p>
<p>This procedure blocks the execution of the current thread, until the semaphore
counter is non-zero, and atomically decrements it by one, once the wait has
ended.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="sema_wait_with_timeout"><span><a class="doc-id-link" href="#sema_wait_with_timeout">sema_wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin#L531"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">sema_wait_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: ^<a class="code-typename" href="/core/sync/#Sema">Sema</a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait on a semaphore until the internal counter is non-zero or a timeout is reached.</p>
<p>This procedure blocks the execution of the current thread, until the semaphore
counter is non-zero, and if so atomically decrements it by one, once the wait
has ended. If the specified timeout is reached, the function returns <code>false</code>,
otherwise it returns <code>true</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ticket_mutex_guard"><span><a class="doc-id-link" href="#ticket_mutex_guard">ticket_mutex_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L324"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ticket_mutex_guard :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Ticket_Mutex">Ticket_Mutex</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Guard the current scope with a lock on a ticket mutex.</p>
<p>This procedure acquires a lock on a ticket mutex. The lock is automatically
released at the end of callee's scope. If the mutex was already locked, this
procedure also blocks until the lock can be acquired.</p>
<p>When a lock has been acquired, all threads attempting to acquire a lock will be
blocked from entering any critical sections associated with the ticket mutex,
until the lock is released.</p>
<p>This procedure always returns <code>true</code>. This makes it easy to define a critical
section by putting the function inside the <code>if</code> statement.</p>
<p><b>Example</b>:</p>
<pre>if ticket_mutex_guard(&m) {
	...
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="ticket_mutex_lock"><span><a class="doc-id-link" href="#ticket_mutex_lock">ticket_mutex_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L285"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ticket_mutex_lock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Ticket_Mutex">Ticket_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Acquire a lock on a ticket mutex.</p>
<p>This procedure acquires a lock on a ticket mutex. If the ticket mutex is held
by another thread, this procedure also blocks the execution until the lock
can be acquired.</p>
<p>Once the lock is acquired, any thread calling <code>ticket_mutex_lock</code> will be
blocked from entering any critical sections associated with the same ticket
mutex, until the lock is released.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ticket_mutex_unlock"><span><a class="doc-id-link" href="#ticket_mutex_unlock">ticket_mutex_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L299"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ticket_mutex_unlock :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (m: ^<a class="code-typename" href="/core/sync/#Ticket_Mutex">Ticket_Mutex</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Release a lock on a ticket mutex.</p>
<p>This procedure releases the lock on a ticket mutex. If any of the threads are
waiting to acquire the lock, exactly one of those threads is unblocked and
allowed into the critical section.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="unpark"><span><a class="doc-id-link" href="#unpark">unpark<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L706"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">unpark :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (p: ^<a class="code-typename" href="/core/sync/#Parker">Parker</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Make the token available.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wait_group_add"><span><a class="doc-id-link" href="#wait_group_add">wait_group_add<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L42"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">wait_group_add :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (wg: ^<a class="code-typename" href="/core/sync/#Wait_Group">Wait_Group</a>, delta: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Increment an internal counter of a wait group.</p>
<p>This procedure atomically increments a number to the specified wait group's
internal counter by a specified amount. This operation can be done on any
thread.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wait_group_done"><span><a class="doc-id-link" href="#wait_group_done">wait_group_done<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L68"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">wait_group_done :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (wg: ^<a class="code-typename" href="/core/sync/#Wait_Group">Wait_Group</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Signal work done by a thread in a wait group.</p>
<p>This procedure decrements the internal counter of the specified wait group and
wakes up the waiting thread. Once the internal counter reaches zero, the waiting
thread resumes execution.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wait_group_wait"><span><a class="doc-id-link" href="#wait_group_wait">wait_group_wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L78"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">wait_group_wait :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (wg: ^<a class="code-typename" href="/core/sync/#Wait_Group">Wait_Group</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait for all worker threads in the wait group.</p>
<p>This procedure blocks the execution of the current thread, until the specified
wait group's internal counter reaches zero.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wait_group_wait_with_timeout"><span><a class="doc-id-link" href="#wait_group_wait_with_timeout">wait_group_wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L97"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">wait_group_wait_with_timeout :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (wg: ^<a class="code-typename" href="/core/sync/#Wait_Group">Wait_Group</a>, duration: time.<a class="code-typename" href="/core/time/#Duration">Duration</a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wait for all worker threads in the wait group, or until timeout is reached.</p>
<p>This procedure blocks the execution of the current thread, until the specified
wait group's internal counter reaches zero, or until the timeout is reached.</p>
<p>This procedure returns <code>false</code>, if the timeout was reached, <code>true</code> otherwise.</p>
</details>
</div>
<h2 id="pkg-Procedure Groups" class="pkg-header">Procedure Groups</h2>
<div class="pkg-entity">
<h3 id="broadcast"><span><a class="doc-id-link" href="#broadcast">broadcast<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L118"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">broadcast :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#cond_broadcast">cond_broadcast</a>,
	<a class="code-procedure" href="/core/sync/#atomic_cond_broadcast">atomic_cond_broadcast</a>,
	<a class="code-procedure" href="/core/sync/#futex_broadcast">futex_broadcast</a>,
}
</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="guard"><span><a class="doc-id-link" href="#guard">guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L9"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">guard :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#mutex_guard">mutex_guard</a>,
	<a class="code-procedure" href="/core/sync/#rw_mutex_guard">rw_mutex_guard</a>,
	<a class="code-procedure" href="/core/sync/#recursive_mutex_guard">recursive_mutex_guard</a>,
	<a class="code-procedure" href="/core/sync/#ticket_mutex_guard">ticket_mutex_guard</a>,
	<a class="code-procedure" href="/core/sync/#benaphore_guard">benaphore_guard</a>,
	<a class="code-procedure" href="/core/sync/#recursive_benaphore_guard">recursive_benaphore_guard</a>,
	<a class="code-procedure" href="/core/sync/#atomic_mutex_guard">atomic_mutex_guard</a>,
	<a class="code-procedure" href="/core/sync/#atomic_recursive_mutex_guard">atomic_recursive_mutex_guard</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_guard">atomic_rw_mutex_guard</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">if guard(&m) {
	...
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lock"><span><a class="doc-id-link" href="#lock">lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L32"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">lock :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#mutex_lock">mutex_lock</a>,
	<a class="code-procedure" href="/core/sync/#rw_mutex_lock">rw_mutex_lock</a>,
	<a class="code-procedure" href="/core/sync/#recursive_mutex_lock">recursive_mutex_lock</a>,
	<a class="code-procedure" href="/core/sync/#ticket_mutex_lock">ticket_mutex_lock</a>,
	<a class="code-procedure" href="/core/sync/#benaphore_lock">benaphore_lock</a>,
	<a class="code-procedure" href="/core/sync/#recursive_benaphore_lock">recursive_benaphore_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_mutex_lock">atomic_mutex_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_recursive_mutex_lock">atomic_recursive_mutex_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_lock">atomic_rw_mutex_lock</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>lock locks m</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="once_do"><span><a class="doc-id-link" href="#once_do">once_do<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin#L556"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">once_do :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#once_do_without_data">once_do_without_data</a>,
	<a class="code-procedure" href="/core/sync/#once_do_without_data_contextless">once_do_without_data_contextless</a>,
	<a class="code-procedure" href="/core/sync/#once_do_with_data">once_do_with_data</a>,
	<a class="code-procedure" href="/core/sync/#once_do_with_data_contextless">once_do_with_data_contextless</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Call a function once.</p>
<p>The <code>once_do</code> procedure group calls a specified function, if it wasn't already
called from the perspective of a specific <code>Once</code> struct.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="post"><span><a class="doc-id-link" href="#post">post<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L107"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">post :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#sema_post">sema_post</a>,
	<a class="code-procedure" href="/core/sync/#atomic_sema_post">atomic_sema_post</a>,
}
</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="shared_guard"><span><a class="doc-id-link" href="#shared_guard">shared_guard<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L26"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">shared_guard :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#rw_mutex_shared_guard">rw_mutex_shared_guard</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_shared_guard">atomic_rw_mutex_shared_guard</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">if shared_guard(&m) {
	...
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="shared_lock"><span><a class="doc-id-link" href="#shared_lock">shared_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L70"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">shared_lock :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#rw_mutex_shared_lock">rw_mutex_shared_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_shared_lock">atomic_rw_mutex_shared_lock</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>shared_lock locks rw for reading (with arbitrary number of readers)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="shared_unlock"><span><a class="doc-id-link" href="#shared_unlock">shared_unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L76"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">shared_unlock :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#rw_mutex_shared_unlock">rw_mutex_shared_unlock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_shared_unlock">atomic_rw_mutex_shared_unlock</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>shared_unlock unlocks rw for reading (with arbitrary number of readers)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="signal"><span><a class="doc-id-link" href="#signal">signal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L112"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">signal :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#cond_signal">cond_signal</a>,
	<a class="code-procedure" href="/core/sync/#atomic_cond_signal">atomic_cond_signal</a>,
	<a class="code-procedure" href="/core/sync/#futex_signal">futex_signal</a>,
}
</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="try_lock"><span><a class="doc-id-link" href="#try_lock">try_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L58"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">try_lock :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#mutex_try_lock">mutex_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#rw_mutex_try_lock">rw_mutex_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#recursive_mutex_try_lock">recursive_mutex_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#benaphore_try_lock">benaphore_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#recursive_benaphore_try_lock">recursive_benaphore_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_mutex_try_lock">atomic_mutex_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_recursive_mutex_try_lock">atomic_recursive_mutex_try_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_try_lock">atomic_rw_mutex_try_lock</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>try_lock tries to lock m, will return true on success, and false on failure</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="try_shared_lock"><span><a class="doc-id-link" href="#try_shared_lock">try_shared_lock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L82"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">try_shared_lock :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#rw_mutex_try_shared_lock">rw_mutex_try_shared_lock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_try_shared_lock">atomic_rw_mutex_try_shared_lock</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>try_shared_lock tries to lock rw for reading (with arbitrary number of readers)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="unlock"><span><a class="doc-id-link" href="#unlock">unlock<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L45"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">unlock :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#mutex_unlock">mutex_unlock</a>,
	<a class="code-procedure" href="/core/sync/#rw_mutex_unlock">rw_mutex_unlock</a>,
	<a class="code-procedure" href="/core/sync/#recursive_mutex_unlock">recursive_mutex_unlock</a>,
	<a class="code-procedure" href="/core/sync/#ticket_mutex_unlock">ticket_mutex_unlock</a>,
	<a class="code-procedure" href="/core/sync/#benaphore_unlock">benaphore_unlock</a>,
	<a class="code-procedure" href="/core/sync/#recursive_benaphore_unlock">recursive_benaphore_unlock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_mutex_unlock">atomic_mutex_unlock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_recursive_mutex_unlock">atomic_recursive_mutex_unlock</a>,
	<a class="code-procedure" href="/core/sync/#atomic_rw_mutex_unlock">atomic_rw_mutex_unlock</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>unlock locks m</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wait"><span><a class="doc-id-link" href="#wait">wait<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L89"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">wait :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#cond_wait">cond_wait</a>,
	<a class="code-procedure" href="/core/sync/#sema_wait">sema_wait</a>,
	<a class="code-procedure" href="/core/sync/#atomic_cond_wait">atomic_cond_wait</a>,
	<a class="code-procedure" href="/core/sync/#atomic_sema_wait">atomic_sema_wait</a>,
	<a class="code-procedure" href="/core/sync/#futex_wait">futex_wait</a>,
	<a class="code-procedure" href="/core/sync/#wait_group_wait">wait_group_wait</a>,
}
</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="wait_with_timeout"><span><a class="doc-id-link" href="#wait_with_timeout">wait_with_timeout<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin#L98"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">wait_with_timeout :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/sync/#cond_wait_with_timeout">cond_wait_with_timeout</a>,
	<a class="code-procedure" href="/core/sync/#sema_wait_with_timeout">sema_wait_with_timeout</a>,
	<a class="code-procedure" href="/core/sync/#atomic_cond_wait_with_timeout">atomic_cond_wait_with_timeout</a>,
	<a class="code-procedure" href="/core/sync/#atomic_sema_wait_with_timeout">atomic_sema_wait_with_timeout</a>,
	<a class="code-procedure" href="/core/sync/#futex_wait_with_timeout">futex_wait_with_timeout</a>,
	<a class="code-procedure" href="/core/sync/#wait_group_wait_with_timeout">wait_group_wait_with_timeout</a>,
}
</pre>
</div>
</div>
</section>
<h2 id="pkg-source-files">Source Files</h2>
<ul>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/atomic.odin">atomic.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/doc.odin">doc.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/extended.odin">extended.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives.odin">primitives.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_atomic.odin">primitives_atomic.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/primitives_internal.odin">primitives_internal.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/sync/sync_util.odin">sync_util.odin</a></li>
<li><em>(hidden platform specific files)</em></li>
</ul>
<h2 id="pkg-generation-information">Generation Information</h2>
<p>Generated with <code>odin version dev-2024-10 (vendor "odin") Windows_amd64 @ 2024-10-29 21:12:29.741431200 +0000 UTC</code></p>
</article>
<div class="col-lg-2 odin-toc-border navbar-light"><div class="sticky-top odin-below-navbar py-3">
<nav id="TableOfContents">
<ul>
<li><a href="#pkg-overview">Overview</a><li><a href="#pkg-Types">Types</a><ul>
<li><a href="#Atomic_Cond">Atomic_Cond</a></li>
<li><a href="#Atomic_Memory_Order">Atomic_Memory_Order</a></li>
<li><a href="#Atomic_Mutex">Atomic_Mutex</a></li>
<li><a href="#Atomic_Mutex_State">Atomic_Mutex_State</a></li>
<li><a href="#Atomic_RW_Mutex">Atomic_RW_Mutex</a></li>
<li><a href="#Atomic_RW_Mutex_State">Atomic_RW_Mutex_State</a></li>
<li><a href="#Atomic_Recursive_Mutex">Atomic_Recursive_Mutex</a></li>
<li><a href="#Atomic_Sema">Atomic_Sema</a></li>
<li><a href="#Auto_Reset_Event">Auto_Reset_Event</a></li>
<li><a href="#Barrier">Barrier</a></li>
<li><a href="#Benaphore">Benaphore</a></li>
<li><a href="#Cond">Cond</a></li>
<li><a href="#Futex">Futex</a></li>
<li><a href="#Mutex">Mutex</a></li>
<li><a href="#Once">Once</a></li>
<li><a href="#One_Shot_Event">One_Shot_Event</a></li>
<li><a href="#Parker">Parker</a></li>
<li><a href="#RW_Mutex">RW_Mutex</a></li>
<li><a href="#Recursive_Benaphore">Recursive_Benaphore</a></li>
<li><a href="#Recursive_Mutex">Recursive_Mutex</a></li>
<li><a href="#Sema">Sema</a></li>
<li><a href="#Ticket_Mutex">Ticket_Mutex</a></li>
<li><a href="#Wait_Group">Wait_Group</a></li>
</ul>
</li>
<li><a href="#pkg-Constants">Constants</a><ul>
<li><a href="#Atomic_RW_Mutex_State_Half_Width">Atomic_RW_Mutex_State_Half_Width</a></li>
<li><a href="#Atomic_RW_Mutex_State_Is_Writing">Atomic_RW_Mutex_State_Is_Writing</a></li>
<li><a href="#Atomic_RW_Mutex_State_Reader">Atomic_RW_Mutex_State_Reader</a></li>
<li><a href="#Atomic_RW_Mutex_State_Reader_Mask">Atomic_RW_Mutex_State_Reader_Mask</a></li>
<li><a href="#Atomic_RW_Mutex_State_Writer">Atomic_RW_Mutex_State_Writer</a></li>
<li><a href="#Atomic_RW_Mutex_State_Writer_Mask">Atomic_RW_Mutex_State_Writer_Mask</a></li>
</ul>
</li>
<li><a href="#pkg-Procedures">Procedures</a><ul>
<li><a href="#atomic_add">atomic_add</a></li>
<li><a href="#atomic_add_explicit">atomic_add_explicit</a></li>
<li><a href="#atomic_and">atomic_and</a></li>
<li><a href="#atomic_and_explicit">atomic_and_explicit</a></li>
<li><a href="#atomic_compare_exchange_strong">atomic_compare_exchange_strong</a></li>
<li><a href="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</a></li>
<li><a href="#atomic_compare_exchange_weak">atomic_compare_exchange_weak</a></li>
<li><a href="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</a></li>
<li><a href="#atomic_cond_broadcast">atomic_cond_broadcast</a></li>
<li><a href="#atomic_cond_signal">atomic_cond_signal</a></li>
<li><a href="#atomic_cond_wait">atomic_cond_wait</a></li>
<li><a href="#atomic_cond_wait_with_timeout">atomic_cond_wait_with_timeout</a></li>
<li><a href="#atomic_exchange">atomic_exchange</a></li>
<li><a href="#atomic_exchange_explicit">atomic_exchange_explicit</a></li>
<li><a href="#atomic_load">atomic_load</a></li>
<li><a href="#atomic_load_explicit">atomic_load_explicit</a></li>
<li><a href="#atomic_mutex_guard">atomic_mutex_guard</a></li>
<li><a href="#atomic_mutex_lock">atomic_mutex_lock</a></li>
<li><a href="#atomic_mutex_try_lock">atomic_mutex_try_lock</a></li>
<li><a href="#atomic_mutex_unlock">atomic_mutex_unlock</a></li>
<li><a href="#atomic_nand">atomic_nand</a></li>
<li><a href="#atomic_nand_explicit">atomic_nand_explicit</a></li>
<li><a href="#atomic_or">atomic_or</a></li>
<li><a href="#atomic_or_explicit">atomic_or_explicit</a></li>
<li><a href="#atomic_recursive_mutex_guard">atomic_recursive_mutex_guard</a></li>
<li><a href="#atomic_recursive_mutex_lock">atomic_recursive_mutex_lock</a></li>
<li><a href="#atomic_recursive_mutex_try_lock">atomic_recursive_mutex_try_lock</a></li>
<li><a href="#atomic_recursive_mutex_unlock">atomic_recursive_mutex_unlock</a></li>
<li><a href="#atomic_rw_mutex_guard">atomic_rw_mutex_guard</a></li>
<li><a href="#atomic_rw_mutex_lock">atomic_rw_mutex_lock</a></li>
<li><a href="#atomic_rw_mutex_shared_guard">atomic_rw_mutex_shared_guard</a></li>
<li><a href="#atomic_rw_mutex_shared_lock">atomic_rw_mutex_shared_lock</a></li>
<li><a href="#atomic_rw_mutex_shared_unlock">atomic_rw_mutex_shared_unlock</a></li>
<li><a href="#atomic_rw_mutex_try_lock">atomic_rw_mutex_try_lock</a></li>
<li><a href="#atomic_rw_mutex_try_shared_lock">atomic_rw_mutex_try_shared_lock</a></li>
<li><a href="#atomic_rw_mutex_unlock">atomic_rw_mutex_unlock</a></li>
<li><a href="#atomic_sema_post">atomic_sema_post</a></li>
<li><a href="#atomic_sema_wait">atomic_sema_wait</a></li>
<li><a href="#atomic_sema_wait_with_timeout">atomic_sema_wait_with_timeout</a></li>
<li><a href="#atomic_signal_fence">atomic_signal_fence</a></li>
<li><a href="#atomic_store">atomic_store</a></li>
<li><a href="#atomic_store_explicit">atomic_store_explicit</a></li>
<li><a href="#atomic_sub">atomic_sub</a></li>
<li><a href="#atomic_sub_explicit">atomic_sub_explicit</a></li>
<li><a href="#atomic_thread_fence">atomic_thread_fence</a></li>
<li><a href="#atomic_xor">atomic_xor</a></li>
<li><a href="#atomic_xor_explicit">atomic_xor_explicit</a></li>
<li><a href="#auto_reset_event_signal">auto_reset_event_signal</a></li>
<li><a href="#auto_reset_event_wait">auto_reset_event_wait</a></li>
<li><a href="#barrier_init">barrier_init</a></li>
<li><a href="#barrier_wait">barrier_wait</a></li>
<li><a href="#benaphore_guard">benaphore_guard</a></li>
<li><a href="#benaphore_lock">benaphore_lock</a></li>
<li><a href="#benaphore_try_lock">benaphore_try_lock</a></li>
<li><a href="#benaphore_unlock">benaphore_unlock</a></li>
<li><a href="#cond_broadcast">cond_broadcast</a></li>
<li><a href="#cond_signal">cond_signal</a></li>
<li><a href="#cond_wait">cond_wait</a></li>
<li><a href="#cond_wait_with_timeout">cond_wait_with_timeout</a></li>
<li><a href="#cpu_relax">cpu_relax</a></li>
<li><a href="#current_thread_id">current_thread_id</a></li>
<li><a href="#futex_broadcast">futex_broadcast</a></li>
<li><a href="#futex_signal">futex_signal</a></li>
<li><a href="#futex_wait">futex_wait</a></li>
<li><a href="#futex_wait_with_timeout">futex_wait_with_timeout</a></li>
<li><a href="#mutex_guard">mutex_guard</a></li>
<li><a href="#mutex_lock">mutex_lock</a></li>
<li><a href="#mutex_try_lock">mutex_try_lock</a></li>
<li><a href="#mutex_unlock">mutex_unlock</a></li>
<li><a href="#once_do_with_data">once_do_with_data</a></li>
<li><a href="#once_do_with_data_contextless">once_do_with_data_contextless</a></li>
<li><a href="#once_do_without_data">once_do_without_data</a></li>
<li><a href="#once_do_without_data_contextless">once_do_without_data_contextless</a></li>
<li><a href="#one_shot_event_signal">one_shot_event_signal</a></li>
<li><a href="#one_shot_event_wait">one_shot_event_wait</a></li>
<li><a href="#park">park</a></li>
<li><a href="#park_with_timeout">park_with_timeout</a></li>
<li><a href="#recursive_benaphore_guard">recursive_benaphore_guard</a></li>
<li><a href="#recursive_benaphore_lock">recursive_benaphore_lock</a></li>
<li><a href="#recursive_benaphore_try_lock">recursive_benaphore_try_lock</a></li>
<li><a href="#recursive_benaphore_unlock">recursive_benaphore_unlock</a></li>
<li><a href="#recursive_mutex_guard">recursive_mutex_guard</a></li>
<li><a href="#recursive_mutex_lock">recursive_mutex_lock</a></li>
<li><a href="#recursive_mutex_try_lock">recursive_mutex_try_lock</a></li>
<li><a href="#recursive_mutex_unlock">recursive_mutex_unlock</a></li>
<li><a href="#rw_mutex_guard">rw_mutex_guard</a></li>
<li><a href="#rw_mutex_lock">rw_mutex_lock</a></li>
<li><a href="#rw_mutex_shared_guard">rw_mutex_shared_guard</a></li>
<li><a href="#rw_mutex_shared_lock">rw_mutex_shared_lock</a></li>
<li><a href="#rw_mutex_shared_unlock">rw_mutex_shared_unlock</a></li>
<li><a href="#rw_mutex_try_lock">rw_mutex_try_lock</a></li>
<li><a href="#rw_mutex_try_shared_lock">rw_mutex_try_shared_lock</a></li>
<li><a href="#rw_mutex_unlock">rw_mutex_unlock</a></li>
<li><a href="#sema_post">sema_post</a></li>
<li><a href="#sema_wait">sema_wait</a></li>
<li><a href="#sema_wait_with_timeout">sema_wait_with_timeout</a></li>
<li><a href="#ticket_mutex_guard">ticket_mutex_guard</a></li>
<li><a href="#ticket_mutex_lock">ticket_mutex_lock</a></li>
<li><a href="#ticket_mutex_unlock">ticket_mutex_unlock</a></li>
<li><a href="#unpark">unpark</a></li>
<li><a href="#wait_group_add">wait_group_add</a></li>
<li><a href="#wait_group_done">wait_group_done</a></li>
<li><a href="#wait_group_wait">wait_group_wait</a></li>
<li><a href="#wait_group_wait_with_timeout">wait_group_wait_with_timeout</a></li>
</ul>
</li>
<li><a href="#pkg-Procedure Groups">Procedure Groups</a><ul>
<li><a href="#broadcast">broadcast</a></li>
<li><a href="#guard">guard</a></li>
<li><a href="#lock">lock</a></li>
<li><a href="#once_do">once_do</a></li>
<li><a href="#post">post</a></li>
<li><a href="#shared_guard">shared_guard</a></li>
<li><a href="#shared_lock">shared_lock</a></li>
<li><a href="#shared_unlock">shared_unlock</a></li>
<li><a href="#signal">signal</a></li>
<li><a href="#try_lock">try_lock</a></li>
<li><a href="#try_shared_lock">try_shared_lock</a></li>
<li><a href="#unlock">unlock</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#wait_with_timeout">wait_with_timeout</a></li>
</ul>
</li>
<li><a href="#pkg-source-files">Source Files</a></ul>
</nav>
</div></div>
<script type="text/javascript">var odin_pkg_name = "sync";</script>
</div>

</div>
</main>

<footer class="odin-footer">
	<div class="container pb-5 pt-5">
		<div class="row g-4">
		<div class="col">
		<a class="navbar-brand" href="https://odin-lang.org">
		<img class="mb-3" src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
		<p>
		The Data-Oriented Language for Sane Software Development.
		</p>
		</div>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Resources</h4>
			<ul class="list-unstyled">
			<li><a href="https://odin-lang.org/docs" class="link-light">Docs</a></li>
			<li><a href="https://pkg.odin-lang.org/" class="link-light">Packages</a></li>
			<li><a href="https://odin-lang.org/news" class="link-light">News</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Community</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin" target="_blank" class="link-light">GitHub</a></li>
			<li><a href="https://discord.com/invite/sVBPHEv" target="_blank" class="link-light">Discord</a></li>
			<li><a href="https://www.twitch.tv/ginger_bill" target="_blank" class="link-light">Twitch</a></li>
			<li><a href="https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg" target="_blank" class="link-light">YouTube</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Contribute</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin/issues" target="_blank" class="link-light">Issues</a></li>
			<li><a href="https://www.patreon.com/gingerbill" target="_blank" class="link-light">Donate</a></li>
			</ul>
			</nav>
		</div>
		<div class="mt-4 text-muted">© 2016–2023 Ginger Bill</div>
	</div>
</footer>

<script src="https://odin-lang.org/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="https://odin-lang.org/js/script.js"></script>
<script src="/pkg-data.js"></script>
<script src="/search.js"></script>
</body>
</html>
